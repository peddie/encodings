<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Initial and Final Encodings</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link href="data:text/css;charset=utf-8,%0Abody%0A%7B%0Amargin%3A%200%200%200%200%3B%0Apadding%3A%200%200%200%200%3B%0Awidth%3A%20100%25%3B%0Aheight%3A%20100%25%3B%0Acolor%3A%20black%3B%0Abackground%2Dcolor%3A%20white%3B%0Afont%2Dfamily%3A%20%22URW%20Palladio%20L%22%2C%20%22Palatino%20Linotype%22%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014pt%3B%0A%7D%0Acode%0A%7B%0Afont%2Dfamily%3A%20%22DejaVu%20Sans%20Mono%22%2C%20monospace%3B%0A%7D%0Adiv%2Etoolbar%20%7B%0Aposition%3A%20fixed%3B%20z%2Dindex%3A%20200%3B%0Atop%3A%20auto%3B%20bottom%3A%200%3B%20left%3A%200%3B%20right%3A%200%3B%0Aheight%3A%201%2E2em%3B%20text%2Dalign%3A%20right%3B%0Apadding%2Dleft%3A%201em%3B%0Apadding%2Dright%3A%201em%3B%20font%2Dsize%3A%2060%25%3B%0Acolor%3A%20red%3B%0Abackground%2Dcolor%3A%20rgb%28240%2C240%2C240%29%3B%0Aborder%2Dtop%3A%20solid%201px%20rgb%28180%2C180%2C180%29%3B%0A%7D%0Adiv%2Etoolbar%20span%2Ecopyright%20%7B%0Acolor%3A%20black%3B%0Amargin%2Dleft%3A%200%2E5em%3B%0A%7D%0Adiv%2Einitial%5Fprompt%20%7B%0Aposition%3A%20absolute%3B%0Az%2Dindex%3A%201000%3B%0Abottom%3A%201%2E2em%3B%0Awidth%3A%20100%25%3B%0Abackground%2Dcolor%3A%20rgb%28200%2C200%2C200%29%3B%0Aopacity%3A%200%2E35%3B%0Abackground%2Dcolor%3A%20rgba%28200%2C200%2C200%2C%200%2E35%29%3B%0Acursor%3A%20pointer%3B%0A%7D%0Adiv%2Einitial%5Fprompt%20p%2Ehelp%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Adiv%2Einitial%5Fprompt%20p%2Eclose%20%7B%0Atext%2Dalign%3A%20right%3B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Adiv%2Eslidy%5Ftoc%20%7B%0Aposition%3A%20absolute%3B%0Az%2Dindex%3A%20300%3B%0Awidth%3A%2060%25%3B%0Amax%2Dwidth%3A%2030em%3B%0Aheight%3A%2030em%3B%0Aoverflow%3A%20auto%3B%0Atop%3A%20auto%3B%0Aright%3A%20auto%3B%0Aleft%3A%204em%3B%0Abottom%3A%204em%3B%0Apadding%3A%201em%3B%0Abackground%3A%20rgb%28240%2C240%2C240%29%3B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%2Dwidth%3A%202px%3B%0Afont%2Dsize%3A%2060%25%3B%0A%7D%0Adiv%2Eslidy%5Ftoc%20%2Etoc%5Fheading%20%7B%0Atext%2Dalign%3A%20center%3B%0Awidth%3A%20100%25%3B%0Amargin%3A%200%3B%0Amargin%2Dbottom%3A%201em%3B%0Aborder%2Dbottom%2Dstyle%3A%20solid%3B%0Aborder%2Dbottom%2Dcolor%3A%20rgb%28180%2C180%2C180%29%3B%0Aborder%2Dbottom%2Dwidth%3A%201px%3B%0A%7D%0Adiv%2Eslide%20%7B%0Az%2Dindex%3A%2020%3B%0Amargin%3A%200%200%200%200%3B%0Apadding%2Dtop%3A%200%3B%0Apadding%2Dbottom%3A%200%3B%0Apadding%2Dleft%3A%2020px%3B%0Apadding%2Dright%3A%2020px%3B%0Aborder%2Dwidth%3A%200%3B%0Aclear%3A%20both%3B%0Atop%3A%200%3B%0Abottom%3A%200%3B%0Aleft%3A%200%3B%0Aright%3A%200%3B%0Aline%2Dheight%3A%20120%25%3B%0Abackground%2Dcolor%3A%20transparent%3B%0A%7D%0Adiv%2Eslide%20%3E%20div%2Efigure%20%7B%0Atext%2Dalign%3A%20center%0A%7D%0Adiv%2Ebackground%20%7B%0Adisplay%3A%20none%3B%0A%7D%0Adiv%2Ehandout%20%7B%0Amargin%2Dleft%3A%2020px%3B%0Amargin%2Dright%3A%2020px%3B%0A%7D%0Adiv%2Eslide%2Etitlepage%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Adiv%2Eslide%2Etitlepage%20h1%20%7B%0Apadding%2Dtop%3A%2010%25%3B%0Amargin%2Dright%3A%200%3B%0A%7D%0Adiv%2Eslide%20h1%20%7B%0Apadding%2Dleft%3A%200%3B%0Apadding%2Dright%3A%2020pt%3B%0Apadding%2Dtop%3A%204pt%3B%0Apadding%2Dbottom%3A%204pt%3B%0Amargin%2Dtop%3A%200%3B%0Amargin%2Dleft%3A%200%3B%0Amargin%2Dright%3A%2060pt%3B%0Amargin%2Dbottom%3A%200%2E5em%3B%0Adisplay%3A%20block%3B%20font%2Dsize%3A%20160%25%3B%0Aline%2Dheight%3A%201%2E2em%3B%0Abackground%3A%20transparent%3B%0A%7D%0A%40media%20screen%20and%20%28max%2Ddevice%2Dwidth%3A%201024px%29%0A%7B%0Adiv%2Eslide%20%7B%20font%2Dsize%3A%20100%25%3B%20%7D%0A%7D%0A%40media%20screen%20and%20%28max%2Ddevice%2Dwidth%3A%20800px%29%0A%7B%0Adiv%2Eslide%20%7B%20font%2Dsize%3A%20200%25%3B%20%7D%0Adiv%2Eslidy%5Ftoc%20%7B%0Atop%3A%201em%3B%0Aleft%3A%201em%3B%0Aright%3A%20auto%3B%0Awidth%3A%2080%25%3B%0Afont%2Dsize%3A%20180%25%3B%0A%7D%0A%7D%0Adiv%2Etoc%2Dheading%20%7B%0Awidth%3A%20100%25%3B%0Aborder%2Dbottom%3A%20solid%201px%20rgb%28180%2C180%2C180%29%3B%0Amargin%2Dbottom%3A%201em%3B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Aimage%2Drendering%3A%20optimize%2Dquality%3B%0A%7D%0Apre%20%7B%0Afont%2Dsize%3A%2080%25%3B%0Afont%2Dweight%3A%20bold%3B%0Aline%2Dheight%3A%20120%25%3B%0Apadding%2Dtop%3A%200%2E2em%3B%0Apadding%2Dbottom%3A%200%2E2em%3B%0Apadding%2Dleft%3A%201em%3B%0Apadding%2Dright%3A%201em%3B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%2Dleft%2Dwidth%3A%201em%3B%0Aborder%2Dtop%2Dwidth%3A%20thin%3B%0Aborder%2Dright%2Dwidth%3A%20thin%3B%0Aborder%2Dbottom%2Dwidth%3A%20thin%3B%0Aborder%2Dcolor%3A%20%2395ABD0%3B%0Acolor%3A%20%2300428C%3B%0Abackground%2Dcolor%3A%20%23E4E5E7%3B%0A%7D%0Ali%20pre%20%7B%20margin%2Dleft%3A%200%3B%20%7D%0Ablockquote%20%7B%20font%2Dstyle%3A%20italic%20%7D%0Aimg%20%7B%20background%2Dcolor%3A%20transparent%20%7D%0Ap%2Ecopyright%20%7B%20font%2Dsize%3A%20smaller%20%7D%0A%2Ecenter%20%7B%20text%2Dalign%3A%20center%20%7D%0A%2Efootnote%20%7B%20font%2Dsize%3A%20smaller%3B%20margin%2Dleft%3A%202em%3B%20%7D%0Aa%20img%20%7B%20border%2Dwidth%3A%200%3B%20border%2Dstyle%3A%20none%20%7D%0Aa%3Avisited%20%7B%20color%3A%20navy%20%7D%0Aa%3Alink%20%7B%20color%3A%20navy%20%7D%0Aa%3Ahover%20%7B%20color%3A%20red%3B%20text%2Ddecoration%3A%20underline%20%7D%0Aa%3Aactive%20%7B%20color%3A%20red%3B%20text%2Ddecoration%3A%20underline%20%7D%0Aa%20%7Btext%2Ddecoration%3A%20none%7D%0A%2Etoolbar%20a%3Alink%20%7Bcolor%3A%20blue%7D%0A%2Etoolbar%20a%3Avisited%20%7Bcolor%3A%20blue%7D%0A%2Etoolbar%20a%3Aactive%20%7Bcolor%3A%20red%7D%0A%2Etoolbar%20a%3Ahover%20%7Bcolor%3A%20red%7D%0Aul%20%7B%20list%2Dstyle%2Dtype%3A%20square%3B%20%7D%0Aul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20disc%3B%20%7D%0Aul%20ul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20circle%3B%20%7D%0Aul%20ul%20ul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20disc%3B%20%7D%0Ali%20%7B%20margin%2Dleft%3A%200%2E5em%3B%20margin%2Dtop%3A%200%2E5em%3B%20font%2Dweight%3A%20bold%20%7D%0Ali%20li%20%7B%20font%2Dsize%3A%2085%25%3B%20font%2Dweight%3A%20normal%20%7D%0Ali%20li%20li%20%7B%20font%2Dsize%3A%2085%25%3B%20font%2Dweight%3A%20normal%20%7D%0Astrong%20%7B%20color%3A%20red%3B%20%7D%0Ali%20li%20strong%20%7B%20color%3A%20black%3B%20%7D%0A%0Ali%20%3E%20p%20%7B%20margin%3A%200em%3B%20%7D%0Adiv%20dt%0A%7B%0Amargin%2Dleft%3A%200%3B%0Amargin%2Dtop%3A%201em%3B%0Amargin%2Dbottom%3A%200%2E5em%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adiv%20dd%0A%7B%0Amargin%2Dleft%3A%202em%3B%0Amargin%2Dbottom%3A%200%2E5em%3B%0A%7D%0Ap%2Cpre%2Cul%2Col%2Cblockquote%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%2Cdl%2Ctable%20%7B%0Amargin%2Dleft%3A%201em%3B%0Amargin%2Dright%3A%201em%3B%0A%7D%0Ap%2Esubhead%20%7B%20font%2Dweight%3A%20bold%3B%20margin%2Dtop%3A%202em%3B%20%7D%0A%2Esmaller%20%7B%20font%2Dsize%3A%20smaller%20%7D%0A%2Ebigger%20%7B%20font%2Dsize%3A%20130%25%20%7D%0Atd%2Cth%20%7B%20padding%3A%200%2E2em%20%7D%0Aul%20%7B%0Amargin%3A%200%2E5em%201%2E5em%200%2E5em%201%2E5em%3B%0Apadding%3A%200%3B%0A%7D%0Aol%20%7B%0Amargin%3A%200%2E5em%201%2E5em%200%2E5em%201%2E5em%3B%0Apadding%3A%200%3B%0A%7D%0Aul%20%7B%20list%2Dstyle%2Dtype%3A%20square%3B%20%7D%0Aul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20disc%3B%20%7D%0Aul%20ul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20circle%3B%20%7D%0Aul%20ul%20ul%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20disc%3B%20%7D%0Aul%20li%20%7B%20list%2Dstyle%3A%20square%3B%0Amargin%3A%200%2E1em%200em%200%2E6em%200%3B%0Apadding%3A%200%200%200%200%3B%0Aline%2Dheight%3A%20140%25%3B%0A%7D%0Aol%20li%20%7B%20margin%3A%200%2E1em%200em%200%2E6em%201%2E5em%3B%0Apadding%3A%200%200%200%200px%3B%0Aline%2Dheight%3A%20140%25%3B%0Alist%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0Ali%20ul%20li%20%7B%20font%2Dsize%3A%2085%25%3B%20font%2Dstyle%3A%20normal%3B%0Alist%2Dstyle%2Dtype%3A%20disc%3B%0Abackground%3A%20transparent%3B%0Apadding%3A%200%200%200%200%3B%0A%7D%0Ali%20li%20ul%20li%20%7B%20font%2Dsize%3A%2085%25%3B%20font%2Dstyle%3A%20normal%3B%0Alist%2Dstyle%2Dtype%3A%20circle%3B%0Abackground%3A%20transparent%3B%0Apadding%3A%200%200%200%200%3B%0A%7D%0Ali%20li%20li%20ul%20li%20%7B%0Alist%2Dstyle%2Dtype%3A%20disc%3B%0Abackground%3A%20transparent%3B%0Apadding%3A%200%200%200%200%3B%0A%7D%0Ali%20ol%20li%20%7B%0Alist%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0Ali%20li%20ol%20li%20%7B%0Alist%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0A%0Aol%2Eoutline%20li%3Ahover%20%7B%20cursor%3A%20pointer%20%7D%0Aol%2Eoutline%20li%2Enofold%3Ahover%20%7B%20cursor%3A%20default%20%7D%0Aul%2Eoutline%20li%3Ahover%20%7B%20cursor%3A%20pointer%20%7D%0Aul%2Eoutline%20li%2Enofold%3Ahover%20%7B%20cursor%3A%20default%20%7D%0Aol%2Eoutline%20%7B%20list%2Dstyle%3Adecimal%3B%20%7D%0Aol%2Eoutline%20ol%20%7B%20list%2Dstyle%2Dtype%3Alower%2Dalpha%20%7D%0Aol%2Eoutline%20li%2Enofold%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAIACAMzMzOvr%2FywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aol%2Eoutline%20li%2Eunfolded%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAMPD%2F8zMzOvr%2F%2F%2F%2F%2FywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aol%2Eoutline%20li%2Efolded%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAMPD%2F8zMzOvr%2F%2F%2F%2F%2FywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aol%2Eoutline%20li%2Eunfolded%3Ahover%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAAAAAAAA%2F8PD%2F%2F%2F%2F%2FywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aol%2Eoutline%20li%2Efolded%3Ahover%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAAAAAAAA%2F8PD%2F%2F%2F%2F%2FywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aul%2Eoutline%20li%2Enofold%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAIACAMzMzOvr%2FywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aul%2Eoutline%20li%2Eunfolded%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAMPD%2F8zMzOvr%2F%2F%2F%2F%2FywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aul%2Eoutline%20li%2Efolded%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAMPD%2F8zMzOvr%2F%2F%2F%2F%2FywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aul%2Eoutline%20li%2Eunfolded%3Ahover%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAAAAAAAA%2F8PD%2F%2F%2F%2F%2FywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0Aul%2Eoutline%20li%2Efolded%3Ahover%20%7B%0Apadding%3A%200%200%200%2020px%3B%0Abackground%3A%20transparent%20data%3Aimage%2Fgif%3Bbase64%2CR0lGODdhCQAJAKEDAAAAAAAA%2F8PD%2F%2F%2F%2F%2FywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs%3D%20no%2Drepeat%200px%200%2E5em%3B%0A%7D%0A%0Aa%2Etitleslide%20%7B%20font%2Dweight%3A%20bold%3B%20font%2Dstyle%3A%20italic%20%7D%0A%0Aimg%2Ehidden%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0Adiv%2Einitial%5Fprompt%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0Adiv%2Eslide%20%7B%0Avisibility%3A%20visible%3B%0Aposition%3A%20inherit%3B%0A%7D%0Adiv%2Ehandout%20%7B%0Aborder%2Dtop%2Dstyle%3A%20solid%3B%0Aborder%2Dtop%2Dwidth%3A%20thin%3B%0Aborder%2Dtop%2Dcolor%3A%20black%3B%0A%7D%0A%40media%20screen%20%7B%0A%2Ehidden%20%7B%20display%3A%20none%3B%20visibility%3A%20visible%20%7D%0Adiv%2Eslide%2Ehidden%20%7B%20display%3A%20block%3B%20visibility%3A%20visible%20%7D%0Adiv%2Ehandout%2Ehidden%20%7B%20display%3A%20block%3B%20visibility%3A%20visible%20%7D%0Adiv%2Ebackground%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0A%2F%2Fbody%2Esingle%5Fslide%20div%2Einitial%5Fprompt%20%7B%20display%3A%20block%3B%20visibility%3A%20visible%20%7D%0Abody%2Esingle%5Fslide%20div%2Einitial%5Fprompt%20%7B%20display%3A%20block%3B%20visibility%3A%20hidden%20%7D%0Abody%2Esingle%5Fslide%20div%2Ebackground%20%7B%20display%3A%20block%3B%20visibility%3A%20visible%20%7D%0Abody%2Esingle%5Fslide%20div%2Ebackground%2Ehidden%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0Abody%2Esingle%5Fslide%20%2Einvisible%20%7B%20visibility%3A%20hidden%20%7D%0Abody%2Esingle%5Fslide%20%2Ehidden%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0Abody%2Esingle%5Fslide%20div%2Eslide%20%7B%20position%3A%20absolute%20%7D%0Abody%2Esingle%5Fslide%20div%2Ehandout%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%20%7D%0A%7D%0A%40media%20print%20%7B%0A%2Ehidden%20%7B%20display%3A%20block%3B%20visibility%3A%20visible%20%7D%0Adiv%2Eslide%20pre%20%7B%20font%2Dsize%3A%2060%25%3B%20padding%2Dleft%3A%200%2E5em%3B%20%7D%0Adiv%2Etoolbar%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%3B%20%7D%0Adiv%2Eslidy%5Ftoc%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%3B%20%7D%0Adiv%2Ebackground%20%7B%20display%3A%20none%3B%20visibility%3A%20hidden%3B%20%7D%0Adiv%2Eslide%20%7B%20page%2Dbreak%2Dbefore%3A%20always%20%7D%0A%0Adiv%2Eslide%2Efirst%2Dslide%20%7B%20page%2Dbreak%2Dbefore%3A%20avoid%20%7D%0A%7D%0A" rel="stylesheet" type="text/css" media="screen, projection, print" />
  <script src="data:application/x-javascript;base64,Lyogc2xpZHkuanMKCiAgIENvcHlyaWdodCAoYykgMjAwNS0yMDEzIFczQyAoTUlULCBFUkNJTSwgS2VpbyksIEFsbCBSaWdodHMgUmVzZXJ2ZWQuCiAgIFczQyBsaWFiaWxpdHksIHRyYWRlbWFyaywgZG9jdW1lbnQgdXNlIGFuZCBzb2Z0d2FyZSBsaWNlbnNpbmcKICAgcnVsZXMgYXBwbHksIHNlZToKCiAgIGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvY29weXJpZ2h0LWRvY3VtZW50cwogICBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsL2NvcHlyaWdodC1zb2Z0d2FyZQoKICAgRGVmaW5lcyBzaW5nbGUgbmFtZSAidzNjX3NsaWR5IiBpbiBnbG9iYWwgbmFtZXNwYWNlCiAgIEFkZHMgZXZlbnQgaGFuZGxlcnMgd2l0aG91dCB0cmFtcGxpbmcgb24gYW55IG90aGVycwoqLwoKLy8gdGhlIHNsaWR5IG9iamVjdCBpbXBsZW1lbnRhdGlvbgp2YXIgdzNjX3NsaWR5ID0gewogIC8vIGNsYXNzaWZ5IHdoaWNoIGtpbmQgb2YgYnJvd3NlciB3ZSdyZSBydW5uaW5nIHVuZGVyCiAgbnNfcG9zOiAodHlwZW9mIHdpbmRvdy5wYWdlWU9mZnNldCE9J3VuZGVmaW5lZCcpLAogIGtodG1sOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgb3BlcmE6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiT3BlcmEiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGFkOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoImlQYWQiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGhvbmU6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiaVBob25lIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgYW5kcm9pZDogKChuYXZpZ2F0b3IudXNlckFnZW50KS5pbmRleE9mKCJBbmRyb2lkIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgaWU6ICh0eXBlb2YgZG9jdW1lbnQuYWxsICE9ICJ1bmRlZmluZWQiICYmICF0aGlzLm9wZXJhKSwKICBpZTY6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDYiKSAhPSAtMSksCiAgaWU3OiAoIXRoaXMubnNfcG9zICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA3IikgIT0gLTEpLAogIGllODogKCF0aGlzLm5zX3BvcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUgOCIpICE9IC0xKSwKICBpZTk6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDkiKSAhPSAtMSksCgogIC8vIGRhdGEgZm9yIHN3aXBlIGFuZCBkb3VibGUgdGFwIGRldGVjdGlvbiBvbiB0b3VjaCBzY3JlZW5zCiAgbGFzdF90YXA6IDAsCiAgcHJldl90YXA6IDAsCiAgc3RhcnRfeDogMCwKICBzdGFydF95OiAwLAogIGRlbHRhX3g6IDAsCiAgZGVsdGFfeTogMCwKCiAgLy8gYXJlIHdlIHJ1bm5pbmcgYXMgWEhUTUw/IChkb2Vzbid0IHdvcmsgb24gT3BlcmEpCiAgaXNfeGh0bWw6IC94bWwvLnRlc3QoZG9jdW1lbnQuY29udGVudFR5cGUpLAoKICBzbGlkZV9udW1iZXI6IDAsIC8vIGludGVnZXIgc2xpZGUgY291bnQ6IDAsIDEsIDIsIC4uLgogIHNsaWRlX251bWJlcl9lbGVtZW50OiBudWxsLCAvLyBlbGVtZW50IGNvbnRhaW5pbmcgc2xpZGUgbnVtYmVyCiAgc2xpZGVzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIHNsaWRlIGRpdidzCiAgbm90ZXM6IFtdLCAvLyBzZXQgdG8gYXJyYXkgb2YgaGFuZG91dCBkaXYncwogIGJhY2tncm91bmRzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIGJhY2tncm91bmQgZGl2J3MKICB0b29sYmFyOiBudWxsLCAvLyBlbGVtZW50IGNvbnRhaW5pbmcgdG9vbGJhcgogIHRpdGxlOiBudWxsLCAvLyBkb2N1bWVudCB0aXRsZQogIGxhc3Rfc2hvd246IG51bGwsIC8vIGxhc3QgaW5jcmVtZW50YWxseSBzaG93biBpdGVtCiAgZW9zOiBudWxsLCAgLy8gc3BhbiBlbGVtZW50IGZvciBlbmQgb2Ygc2xpZGUgaW5kaWNhdG9yCiAgdG9jOiBudWxsLCAvLyB0YWJsZSBvZiBjb250ZW50cwogIG91dGxpbmU6IG51bGwsIC8vIG91dGxpbmUgZWxlbWVudCB3aXRoIHRoZSBmb2N1cwogIHNlbGVjdGVkX3RleHRfbGVuOiAwLCAvLyBsZW5ndGggb2YgZHJhZyBzZWxlY3Rpb24gb24gZG9jdW1lbnQKICB2aWV3X2FsbDogMCwgIC8vIDEgdG8gdmlldyBhbGwgc2xpZGVzICsgaGFuZG91dHMKICB3YW50X3Rvb2xiYXI6IHRydWUsICAvLyB1c2VyIHByZWZlcmVuY2UgdG8gc2hvdy9oaWRlIHRvb2xiYXIKICBtb3VzZV9jbGlja19lbmFibGVkOiB0cnVlLCAvLyBlbmFibGVzIGxlZnQgY2xpY2sgZm9yIG5leHQgc2xpZGUKICBzY3JvbGxfaGFjazogMCwgLy8gSUUgd29yayBhcm91bmQgZm9yIHBvc2l0aW9uOiBmaXhlZAogIGRpc2FibGVfc2xpZGVfY2xpY2s6IGZhbHNlLCAgLy8gdXNlZCBieSBjbGlja2VkIGFuY2hvcnMKCiAgbGFuZzogImVuIiwgLy8gdXBkYXRlZCB0byBsYW5ndWFnZSBzcGVjaWZpZWQgYnkgaHRtbCBmaWxlCgogIGhlbHBfYW5jaG9yOiBudWxsLCAvLyB1c2VkIGZvciBrZXlib2FyZCBmb2N1cyBoYWNrIGluIHNob3dUb29sYmFyKCkKICBoZWxwX3BhZ2U6ICJodHRwOi8vd3d3LnczLm9yZy9UYWxrcy9Ub29scy9TbGlkeTIvaGVscC9oZWxwLmh0bWwiLAogIGhlbHBfdGV4dDogIk5hdmlnYXRlIHdpdGggbW91c2UgY2xpY2ssIHNwYWNlIGJhciwgQ3Vyc29yIExlZnQvUmlnaHQsICIgKwogICAgICAgICAgICAgIm9yIFBnIFVwIGFuZCBQZyBEbi4gVXNlIFMgYW5kIEIgdG8gY2hhbmdlIGZvbnQgc2l6ZS4iLAoKICBzaXplX2luZGV4OiAwLAogIHNpemVfYWRqdXN0bWVudDogMCwKICBzaXplczogIG5ldyBBcnJheSgiMTBwdCIsICIxMnB0IiwgIjE0cHQiLCAiMTZwdCIsICIxOHB0IiwgIjIwcHQiLAogICAgICAgICAgICAgICAgICAgICIyMnB0IiwgIjI0cHQiLCAiMjZwdCIsICIyOHB0IiwgIjMwcHQiLCAiMzJwdCIpLAoKICAvLyBuZWVkZWQgZm9yIGVmZmljaWVudCByZXNpemluZwogIGxhc3Rfd2lkdGg6IDAsCiAgbGFzdF9oZWlnaHQ6IDAsCgoKICAvLyBOZWVkZWQgZm9yIGNyb3NzIGJyb3dzZXIgc3VwcG9ydCBmb3IgcmVsYXRpdmUgd2lkdGgvaGVpZ2h0IG9uCiAgLy8gb2JqZWN0IGVsZW1lbnRzLiBUaGUgd29yayBhcm91bmQgaXMgdG8gc2F2ZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlcwogIC8vIGFuZCB0aGVuIHRvIHJlY29tcHV0ZSBhYnNvbHV0ZSB3aWR0aC9oZWlnaHQgZGltZW5zaW9ucyBvbiByZXNpemluZwogICBvYmplY3RzOiBbXSwKCiAgLy8gYXR0YWNoIGluaXRpYWxpYXRpb24gZXZlbnQgaGFuZGxlcnMKICBzZXRfdXA6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7IHczY19zbGlkeS5pbml0KCk7IH07CiAgICBpZiAodHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9ICJ1bmRlZmluZWQiKQogICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsIGluaXQsIGZhbHNlKTsKICAgIGVsc2UKICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCJvbmxvYWQiLCBpbml0KTsKICB9LAoKICBoaWRlX3NsaWRlczogZnVuY3Rpb24gKCkgewogICAgaWYgKGRvY3VtZW50LmJvZHkgJiYgIXczY19zbGlkeS5pbml0aWFsaXplZCkKICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS52aXNpYmlsaXR5ID0gImhpZGRlbiI7CiAgICBlbHNlCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmhpZGVfc2xpZGVzLCA1MCk7CiAgfSwKCiAgLy8gaGFjayB0byBwZXJzdWFkZSBJRSB0byBjb21wdXRlIGNvcnJlY3QgZG9jdW1lbnQgaGVpZ2h0CiAgLy8gYXMgbmVlZGVkIGZvciBzaW11bGF0aW5nIGZpeGVkIHBvc2l0aW9uaW5nIG9mIHRvb2xiYXIKICBpZV9oYWNrOiBmdW5jdGlvbiAoKSB7CiAgICB3aW5kb3cucmVzaXplQnkoMCwtMSk7CiAgICB3aW5kb3cucmVzaXplQnkoMCwgMSk7CiAgfSwKCiAgaW5pdDogZnVuY3Rpb24gKCkgewogICAgLy9hbGVydCgic2xpZHkgc3RhcnRpbmcgdGVzdCAxMCIpOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS52aXNpYmlsaXR5ID0gInZpc2libGUiOwogICAgdGhpcy5pbml0X2xvY2FsaXphdGlvbigpOwogICAgdGhpcy5hZGRfdG9vbGJhcigpOwogICAgdGhpcy53cmFwX2ltcGxpY2l0X3NsaWRlcygpOwogICAgdGhpcy5jb2xsZWN0X3NsaWRlcygpOwogICAgdGhpcy5jb2xsZWN0X25vdGVzKCk7CiAgICB0aGlzLmNvbGxlY3RfYmFja2dyb3VuZHMoKTsKICAgIHRoaXMub2JqZWN0cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm9iamVjdCIpOwogICAgdGhpcy5wYXRjaF9hbmNob3JzKCk7CiAgICB0aGlzLnNsaWRlX251bWJlciA9IHRoaXMuZmluZF9zbGlkZV9udW1iZXIobG9jYXRpb24uaHJlZik7CiAgICB3aW5kb3cub2Zmc2NyZWVuYnVmZmVyaW5nID0gdHJ1ZTsKICAgIHRoaXMuc2l6ZV9hZGp1c3RtZW50ID0gdGhpcy5maW5kX3NpemVfYWRqdXN0KCk7CiAgICB0aGlzLnRpbWVfbGVmdCA9IHRoaXMuZmluZF9kdXJhdGlvbigpOwogICAgdGhpcy5oaWRlX2ltYWdlX3Rvb2xiYXIoKTsgIC8vIHN1cHByZXNzIElFIGltYWdlIHRvb2xiYXIgcG9wdXAKICAgIHRoaXMuaW5pdF9vdXRsaW5lcigpOyAgLy8gYWN0aXZhdGUgZm9sZC91bmZvbGQgc3VwcG9ydAogICAgdGhpcy50aXRsZSA9IGRvY3VtZW50LnRpdGxlOwogICAgdGhpcy5rZXlib2FyZGxlc3MgPSAodGhpcy5pcGFkfHx0aGlzLmlwaG9uZXx8dGhpcy5hbmRyb2lkKTsKCiAgICBpZiAodGhpcy5rZXlib2FyZGxlc3MpCiAgICB7CiAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3ModzNjX3NsaWR5LnRvb2xiYXIsICJoaWRkZW4iKQogICAgICB0aGlzLndhbnRfdG9vbGJhciA9IDA7CiAgICB9CgogICAgLy8gd29yayBhcm91bmQgZm9yIG9wZXJhIGJ1ZwogICAgdGhpcy5pc194aHRtbCA9IChkb2N1bWVudC5ib2R5LnRhZ05hbWUgPT0gIkJPRFkiID8gZmFsc2UgOiB0cnVlKTsKCiAgICBpZiAodGhpcy5zbGlkZXMubGVuZ3RoID4gMCkKICAgIHsKICAgICAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5zbGlkZV9udW1iZXJdOwogICAKICAgICAgaWYgKHRoaXMuc2xpZGVfbnVtYmVyID4gMCkKICAgICAgewogICAgICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICAgICAgdGhpcy5sYXN0X3Nob3duID0gdGhpcy5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogICAgICAgIHRoaXMuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdGhpcy5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB0aGlzLnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdGhpcy5zZXRfZW9zX3N0YXR1cyghdGhpcy5uZXh0X2luY3JlbWVudGFsX2l0ZW0odGhpcy5sYXN0X3Nob3duKSk7CiAgICAgIH0KCiAgICAgIHRoaXMuc2V0X2xvY2F0aW9uKCk7CiAgICAgIHRoaXMuYWRkX2NsYXNzKHRoaXMuc2xpZGVzWzBdLCAiZmlyc3Qtc2xpZGUiKTsKICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgfQoKICAgIHRoaXMudG9jID0gdGhpcy50YWJsZV9vZl9jb250ZW50cygpOwoKICAgIHRoaXMuYWRkX2luaXRpYWxfcHJvbXB0KCk7CgogICAgLy8gYmluZCBldmVudCBoYW5kbGVycyB3aXRob3V0IGludGVyZmVyaW5nIHdpdGggY3VzdG9tIHBhZ2Ugc2NyaXB0cwogICAgLy8gVGFwIGV2ZW50cyBiZWhhdmUgdG9vIHdlaXJkbHkgdG8gc3VwcG9ydCBjbGlja3MgcmVsaWFibHkgb24KICAgIC8vIGlQaG9uZSBhbmQgaVBhZCwgc28gZXhjbHVkZSB0aGVzZSBmcm9tIGNsaWNrIGhhbmRsZXIKCiAgICBpZiAoIXRoaXMua2V5Ym9hcmRsZXNzKQogICAgewogICAgICB0aGlzLmFkZF9saXN0ZW5lcihkb2N1bWVudC5ib2R5LCAiY2xpY2siLCB0aGlzLm1vdXNlX2J1dHRvbl9jbGljayk7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LmJvZHksICJtb3VzZWRvd24iLCB0aGlzLm1vdXNlX2J1dHRvbl9kb3duKTsKICAgIH0KCiAgICB0aGlzLmFkZF9saXN0ZW5lcihkb2N1bWVudCwgImtleWRvd24iLCB0aGlzLmtleV9kb3duKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAia2V5cHJlc3MiLCB0aGlzLmtleV9wcmVzcyk7CiAgICB0aGlzLmFkZF9saXN0ZW5lcih3aW5kb3csICJyZXNpemUiLCB0aGlzLnJlc2l6ZWQpOwogICAgdGhpcy5hZGRfbGlzdGVuZXIod2luZG93LCAic2Nyb2xsIiwgdGhpcy5zY3JvbGxlZCk7CiAgICB0aGlzLmFkZF9saXN0ZW5lcih3aW5kb3csICJ1bmxvYWQiLCB0aGlzLnVubG9hZGVkKTsKCiAgICB0aGlzLmFkZF9saXN0ZW5lcihkb2N1bWVudCwgImdlc3R1cmVjaGFuZ2UiLCBmdW5jdGlvbiAoKQogICAgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9KTsKCiAgICB0aGlzLmF0dGFjaF90b3VjaF9oYW5kZXJzKHRoaXMuc2xpZGVzKTsKCiAgICAvLyB0aGlzIHNlZW1zIHRvIGJlIGEgZGVidWdnaW5nIGhhY2sKICAgIC8vaWYgKCFkb2N1bWVudC5ib2R5Lm9uY2xpY2spCiAgICAvLyAgZG9jdW1lbnQuYm9keS5vbmNsaWNrID0gZnVuY3Rpb24gKCkgeyB9OwoKICAgIHRoaXMuc2luZ2xlX3NsaWRlX3ZpZXcoKTsKCiAgICAvL3RoaXMuc2V0X2xvY2F0aW9uKCk7CgogICAgdGhpcy5yZXNpemVkKCk7CgogICAgaWYgKHRoaXMuaWU3KQogICAgICBzZXRUaW1lb3V0KHczY19zbGlkeS5pZV9oYWNrLCAxMDApOwoKICAgIHRoaXMuc2hvd190b29sYmFyKCk7CgogICAgLy8gZm9yIGJhY2sgYnV0dG9uIGRldGVjdGlvbgogICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyB3M2Nfc2xpZHkuY2hlY2tfbG9jYXRpb24oKTsgfSwgMjAwKTsKICAgIHczY19zbGlkeS5pbml0aWFsaXplZCA9IHRydWU7CiAgfSwKCiAgLy8gY3JlYXRlIGRpdiBlbGVtZW50IHdpdGggbGlua3MgdG8gZWFjaCBzbGlkZQogIHRhYmxlX29mX2NvbnRlbnRzOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdG9jID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICB0aGlzLmFkZF9jbGFzcyh0b2MsICJzbGlkeV90b2MgaGlkZGVuIik7CiAgICAvL3RvYy5zZXRBdHRyaWJ1dGUoInRhYmluZGV4IiwgIjAiKTsKCiAgICB2YXIgaGVhZGluZyA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgdGhpcy5hZGRfY2xhc3MoaGVhZGluZywgInRvYy1oZWFkaW5nIik7CiAgICBoZWFkaW5nLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoIlRhYmxlIG9mIENvbnRlbnRzIik7CgogICAgdG9jLmFwcGVuZENoaWxkKGhlYWRpbmcpOwogICAgdmFyIHByZXZpb3VzID0gbnVsbDsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgKytpKQogICAgewogICAgICB2YXIgdGl0bGUgPSB0aGlzLmhhc19jbGFzcyh0aGlzLnNsaWRlc1tpXSwgInRpdGxlIik7CiAgICAgIHZhciBudW0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgoaSArIDEpICsgIi4gIik7CgogICAgICB0b2MuYXBwZW5kQ2hpbGQobnVtKTsKCiAgICAgIHZhciBhID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiYSIpOwogICAgICBhLnNldEF0dHJpYnV0ZSgiaHJlZiIsICIjKCIgKyAoaSsxKSArICIpIik7CgogICAgICBpZiAodGl0bGUpCiAgICAgICAgdGhpcy5hZGRfY2xhc3MoYSwgInRpdGxlc2xpZGUiKTsKCiAgICAgIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5zbGlkZV9uYW1lKGkpKTsKICAgICAgYS5hcHBlbmRDaGlsZChuYW1lKTsKICAgICAgYS5vbmNsaWNrID0gdzNjX3NsaWR5LnRvY19jbGljazsKICAgICAgYS5vbmtleWRvd24gPSB3M2Nfc2xpZHkudG9jX2tleV9kb3duOwogICAgICBhLnByZXZpb3VzID0gcHJldmlvdXM7CgogICAgICBpZiAocHJldmlvdXMpCiAgICAgICAgcHJldmlvdXMubmV4dCA9IGE7CgogICAgICB0b2MuYXBwZW5kQ2hpbGQoYSk7CgogICAgICBpZiAoaSA9PSAwKQogICAgICAgIHRvYy5maXJzdCA9IGE7CgogICAgICBpZiAoaSA8IHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEpCiAgICAgIHsKICAgICAgICB2YXIgYnIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJiciIpOwogICAgICAgIHRvYy5hcHBlbmRDaGlsZChicik7CiAgICAgIH0KCiAgICAgIHByZXZpb3VzID0gYTsKICAgIH0KCiAgICB0b2MuZm9jdXMgPSBmdW5jdGlvbiAoKSB7CiAgICAgIGlmICh0aGlzLmZpcnN0KQogICAgICAgIHRoaXMuZmlyc3QuZm9jdXMoKTsKICAgIH0KCiAgICB0b2Mub25tb3VzZXVwID0gdzNjX3NsaWR5Lm1vdXNlX2J1dHRvbl91cDsKCiAgICB0b2Mub25jbGljayA9IGZ1bmN0aW9uIChlKSB7CiAgICAgIGV8fChlPXdpbmRvdy5ldmVudCk7CgogICAgICBpZiAodzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuIDw9IDApCiAgICAgICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKHRydWUpOwoKICAgICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICAKICAgICAgaWYgKGUuY2FuY2VsICE9IHVuZGVmaW5lZCkKICAgICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIAogICAgICBpZiAoZS5yZXR1cm5WYWx1ZSAhPSB1bmRlZmluZWQpCiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOwogICAgICAKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfTsKCiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSh0b2MsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7CiAgICByZXR1cm4gdG9jOwogIH0sCgogIGlzX3Nob3duX3RvYzogZnVuY3Rpb24gKCkgewogICAgcmV0dXJuICF3M2Nfc2xpZHkuaGFzX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKTsKICB9LAoKICBzaG93X3RhYmxlX29mX2NvbnRlbnRzOiBmdW5jdGlvbiAoKSB7CiAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKTsKICAgIHZhciB0b2MgPSB3M2Nfc2xpZHkudG9jOwogICAgdG9jLmZvY3VzKCk7CgogICAgaWYgKHczY19zbGlkeS5pZTcgJiYgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9PSAwKQogICAgICBzZXRUaW1lb3V0KHczY19zbGlkeS5pZV9oYWNrLCAxMDApOwogIH0sCgogIGhpZGVfdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uIChmb2N1cykgewogICAgdzNjX3NsaWR5LmFkZF9jbGFzcyh3M2Nfc2xpZHkudG9jLCAiaGlkZGVuIik7CgogICAgaWYgKGZvY3VzICYmICF3M2Nfc2xpZHkub3BlcmEgJiYKICAgICAgICAhdzNjX3NsaWR5Lmhhc19jbGFzcyh3M2Nfc2xpZHkudG9jLCAiaGlkZGVuIikpCiAgICAgIHczY19zbGlkeS5oZWxwX2FuY2hvci5mb2N1cygpOwogIH0sCgogIHRvZ2dsZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5pc19zaG93bl90b2MoKSkKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CiAgICBlbHNlCiAgICAgIHczY19zbGlkeS5zaG93X3RhYmxlX29mX2NvbnRlbnRzKCk7CiAgfSwKCiAgLy8gY2FsbGVkIG9uIGNsaWNraW5nIHRvYyBlbnRyeQogIHRvY19jbGljazogZnVuY3Rpb24gKGUpIHsKICAgIGlmICghZSkKICAgICAgZSA9IHdpbmRvdy5ldmVudDsKCiAgICB2YXIgdGFyZ2V0ID0gdzNjX3NsaWR5LmdldF90YXJnZXQoZSk7CgogICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkKICAgIHsKICAgICAgdmFyIHVyaSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoImhyZWYiKTsKCiAgICAgIGlmICh1cmkpCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJnb2luZyB0byAiICsgdXJpKTsKICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LmZpbmRfc2xpZGVfbnVtYmVyKHVyaSk7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgIC8vdGFyZ2V0LmZvY3VzKCk7CgogICAgICAgIHRyeQogICAgICAgIHsKICAgICAgICAgIGlmICghdzNjX3NsaWR5Lm9wZXJhKQogICAgICAgICAgICB3M2Nfc2xpZHkuaGVscF9hbmNob3IuZm9jdXMoKTsKICAgICAgICB9CiAgICAgICAgY2F0Y2ggKGUpCiAgICAgICAgewogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKHRydWUpOwogICAgaWYgKHczY19zbGlkeS5pZTcpIHczY19zbGlkeS5pZV9oYWNrKCk7CiAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGUpOwogIH0sCgogIC8vIGNhbGxlZCBvbmtleWRvd24gZm9yIHRvYyBlbnRyeQogIHRvY19rZXlfZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICB2YXIga2V5OwoKICAgIGlmICghZXZlbnQpCiAgICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudDsKCiAgICAvLyBrbHVkZ2UgYXJvdW5kIE5TL0lFIGRpZmZlcmVuY2VzIAogICAgaWYgKHdpbmRvdy5ldmVudCkKICAgICAga2V5ID0gd2luZG93LmV2ZW50LmtleUNvZGU7CiAgICBlbHNlIGlmIChldmVudC53aGljaCkKICAgICAga2V5ID0gZXZlbnQud2hpY2g7CiAgICBlbHNlCiAgICAgIHJldHVybiB0cnVlOyAvLyBZaWtlcyEgdW5rbm93biBicm93c2VyCgogICAgLy8gaWdub3JlIGV2ZW50IGlmIGtleSB2YWx1ZSBpcyB6ZXJvCiAgICAvLyBhcyBmb3IgYWx0IG9uIE9wZXJhIGFuZCBLb25xdWVyb3IKICAgIGlmICgha2V5KQogICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBjaGVjayBmb3IgY29uY3VycmVudCBjb250cm9sL2NvbW1hbmQvYWx0IGtleQogICAgLy8gYnV0IGFyZSB0aGVzZSBvbmx5IHByZXNlbnQgb24gbW91c2UgZXZlbnRzPwoKICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSkKICAgICAgcmV0dXJuIHRydWU7CgogICAgaWYgKGtleSA9PSAxMykKICAgIHsKICAgICAgdmFyIHVyaSA9IHRoaXMuZ2V0QXR0cmlidXRlKCJocmVmIik7CgogICAgICBpZiAodXJpKQogICAgICB7CiAgICAgICAgLy9hbGVydCgiZ29pbmcgdG8gIiArIHVyaSk7CiAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LmZpbmRfc2xpZGVfbnVtYmVyKHVyaSk7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgIC8vdGFyZ2V0LmZvY3VzKCk7CgogICAgICAgIHRyeQogICAgICAgIHsKICAgICAgICAgIGlmICghdzNjX3NsaWR5Lm9wZXJhKQogICAgICAgICAgICB3M2Nfc2xpZHkuaGVscF9hbmNob3IuZm9jdXMoKTsKICAgICAgICB9CiAgICAgICAgY2F0Y2ggKGUpCiAgICAgICAgewogICAgICAgIH0KICAgICAgfQoKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CgogICAgICBpZiAoc2VsZi5pZTcpCiAgICAgICB3M2Nfc2xpZHkuaWVfaGFjaygpOwoKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQoKICAgIGlmIChrZXkgPT0gNDAgJiYgdGhpcy5uZXh0KQogICAgewogICAgICB0aGlzLm5leHQuZm9jdXMoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQoKICAgIGlmIChrZXkgPT0gMzggJiYgdGhpcy5wcmV2aW91cykKICAgIHsKICAgICAgdGhpcy5wcmV2aW91cy5mb2N1cygpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGUpCiAgewogICAgLy8gYSBkb3VibGUgdG91Y2ggb2Z0ZW4gc3RhcnRzIHdpdGggYQogICAgLy8gc2luZ2xlIHRvdWNoIGR1ZSB0byBmaW5nZXJzIHRvdWNoaW5nCiAgICAvLyBkb3duIGF0IHNsaWdodGx5IGRpZmZlcmVudCB0aW1lcwogICAgLy8gdGh1cyBhdm9pZCBjYWxsaW5nIHByZXZlbnREZWZhdWx0IGhlcmUKICAgIHRoaXMucHJldl90YXAgPSB0aGlzLmxhc3RfdGFwOwogICAgdGhpcy5sYXN0X3RhcCA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpOwoKICAgIHZhciB0YXBfZGVsYXkgPSB0aGlzLmxhc3RfdGFwIC0gdGhpcy5wcmV2X3RhcDsKCiAgICBpZiAodGFwX2RlbGF5IDw9IDIwMCkKICAgIHsKICAgICAgLy8gZG91YmxlIHRhcAogICAgfQoKICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTsKCiAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7CiAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7CiAgICB0aGlzLnNjcmVlblggPSB0b3VjaC5zY3JlZW5YOwogICAgdGhpcy5zY3JlZW5ZID0gdG91Y2guc2NyZWVuWTsKICAgIHRoaXMuY2xpZW50WCA9IHRvdWNoLmNsaWVudFg7CiAgICB0aGlzLmNsaWVudFkgPSB0b3VjaC5jbGllbnRZOwoKICAgIHRoaXMuZGVsdGFfeCA9IHRoaXMuZGVsdGFfeSA9IDA7CiAgfSwKCiAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZSkKICB7CiAgICAvLyBvdmVycmlkZSBuYXRpdmUgZ2VzdHVyZXMgZm9yIHNpbmdsZSB0b3VjaAogICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKQogICAgICByZXR1cm47CgogICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdOwogICAgdGhpcy5kZWx0YV94ID0gdG91Y2gucGFnZVggLSB0aGlzLnBhZ2VYOwogICAgdGhpcy5kZWx0YV95ID0gdG91Y2gucGFnZVkgLSB0aGlzLnBhZ2VZOwogIH0sCgogIHRvdWNoZW5kOiBmdW5jdGlvbiAoZSkKICB7CiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGZvciBtdWx0aS10b3VjaAogICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKQogICAgICByZXR1cm47CgogICAgdmFyIGRlbGF5ID0gKG5ldyBEYXRlKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RfdGFwOwogICAgdmFyIGR4ID0gdGhpcy5kZWx0YV94OwogICAgdmFyIGR5ID0gdGhpcy5kZWx0YV95OwogICAgdmFyIGFic19keCA9IE1hdGguYWJzKGR4KTsKICAgIHZhciBhYnNfZHkgPSBNYXRoLmFicyhkeSk7CgogICAgaWYgKGRlbGF5IDwgNTAwICYmIChhYnNfZHggPiAxMDAgfHwgYWJzX2R5ID4gMTAwKSkKICAgIHsKICAgICAgaWYgKGFic19keCA+IDAuNSAqIGFic19keSkKICAgICAgewogICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKCiAgICAgICAgaWYgKGR4IDwgMCkKICAgICAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKHRydWUpOwogICAgICAgIGVsc2UKICAgICAgICAgIHczY19zbGlkeS5wcmV2aW91c19zbGlkZSh0cnVlKTsKICAgICAgfQogICAgICBlbHNlIGlmIChhYnNfZHkgPiAyICogYWJzX2R4KQogICAgICB7CiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIHczY19zbGlkeS50b2dnbGVfdGFibGVfb2ZfY29udGVudHMoKTsKICAgICAgfQogICAgfQogIH0sCgogIC8vICMjIyBPQlNPTEVURSAjIyMKICBiZWZvcmVfcHJpbnQ6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuc2hvd19hbGxfc2xpZGVzKCk7CiAgICB0aGlzLmhpZGVfdG9vbGJhcigpOwogICAgYWxlcnQoImJlZm9yZSBwcmludCIpOwogIH0sCgogIC8vICMjIyBPQlNPTEVURSAjIyMKICBhZnRlcl9wcmludDogZnVuY3Rpb24gKCkgewogICAgaWYgKCF0aGlzLnZpZXdfYWxsKQogICAgewogICAgICB0aGlzLnNpbmdsZV9zbGlkZV92aWV3KCk7CiAgICAgIHRoaXMuc2hvd190b29sYmFyKCk7CiAgICB9CiAgICBhbGVydCgiYWZ0ZXIgcHJpbnQiKTsKICB9LAoKICAvLyAjIyMgT0JTT0xFVEUgIyMjCiAgcHJpbnRfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICB0aGlzLmJlZm9yZV9wcmludCgpOwogICAgd2luZG93LnByaW50KCk7CiAgICB0aGlzLmFmdGVyX3ByaW50KCk7CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFID8/ICMjIwogIHRvZ2dsZV92aWV3OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy52aWV3X2FsbCkKICAgIHsKICAgICAgdGhpcy5zaW5nbGVfc2xpZGVfdmlldygpOwogICAgICB0aGlzLnNob3dfdG9vbGJhcigpOwogICAgICB0aGlzLnZpZXdfYWxsID0gMDsKICAgIH0KICAgIGVsc2UKICAgIHsKICAgICAgdGhpcy5zaG93X2FsbF9zbGlkZXMoKTsKICAgICAgdGhpcy5oaWRlX3Rvb2xiYXIoKTsKICAgICAgdGhpcy52aWV3X2FsbCA9IDE7CiAgICB9CiAgfSwKCiAgLy8gcHJlcGFyZSBmb3IgcHJpbnRpbmcgICMjIyBPQlNPTEVURSAjIyMKICBzaG93X2FsbF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMucmVtb3ZlX2NsYXNzKGRvY3VtZW50LmJvZHksICJzaW5nbGVfc2xpZGUiKTsKICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgfSwKCiAgLy8gcmVzdG9yZSBhZnRlciBwcmludGluZyAgIyMjIE9CU09MRVRFICMjIwogIHNpbmdsZV9zbGlkZV92aWV3OiBmdW5jdGlvbiAoKSB7CiAgICB0aGlzLmFkZF9jbGFzcyhkb2N1bWVudC5ib2R5LCAic2luZ2xlX3NsaWRlIik7CiAgICB0aGlzLnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgidmlzaWJsZSIpOwogICAgdGhpcy5sYXN0X3Nob3duID0gdGhpcy5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogIH0sCgogIC8vIHN1cHByZXNzIElFJ3MgaW1hZ2UgdG9vbGJhciBwb3AgdXAKICBoaWRlX2ltYWdlX3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdGhpcy5uc19wb3MpCiAgICB7CiAgICAgIHZhciBpbWFnZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiSU1HIik7CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSkKICAgICAgICBpbWFnZXNbaV0uc2V0QXR0cmlidXRlKCJnYWxsZXJ5aW1nIiwgIm5vIik7CiAgICB9CiAgfSwKCiAgdW5sb2FkZWQ6IGZ1bmN0aW9uIChlKSB7CiAgICAvL2FsZXJ0KCJ1bmxvYWRlZCIpOwogIH0sCgogIC8vIFNhZmFyaSBhbmQgS29ucXVlcm9yIGRvbid0IHlldCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUoKQogIC8vIGFuZCB0aGV5IGFsd2F5cyByZWxvYWQgcGFnZSB3aGVuIGxvY2F0aW9uLmhyZWYgaXMgdXBkYXRlZAogIGlzX0tIVE1MOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50OwogICAgcmV0dXJuIChhZ2VudC5pbmRleE9mKCJLSFRNTCIpID49IDAgPyB0cnVlIDogZmFsc2UpOwogIH0sCgogIC8vIGZpbmQgc2xpZGUgbmFtZSBmcm9tIGZpcnN0IGgxIGVsZW1lbnQKICAvLyBkZWZhdWx0IHRvIGRvY3VtZW50IHRpdGxlICsgc2xpZGUgbnVtYmVyCiAgc2xpZGVfbmFtZTogZnVuY3Rpb24gKGluZGV4KSB7CiAgICB2YXIgbmFtZSA9IG51bGw7CiAgICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1tpbmRleF07CgogICAgdmFyIGhlYWRpbmcgPSB0aGlzLmZpbmRfaGVhZGluZyhzbGlkZSk7CgogICAgaWYgKGhlYWRpbmcpCiAgICAgIG5hbWUgPSB0aGlzLmV4dHJhY3RfdGV4dChoZWFkaW5nKTsKCiAgICBpZiAoIW5hbWUpCiAgICAgIG5hbWUgPSB0aGlzLnRpdGxlICsgIigiICsgKGluZGV4ICsgMSkgKyAiKSI7CgogICAgbmFtZS5yZXBsYWNlKC9cJi9nLCAiJmFtcDsiKTsKICAgIG5hbWUucmVwbGFjZSgvXDwvZywgIiZsdDsiKTsKICAgIG5hbWUucmVwbGFjZSgvXD4vZywgIiZndDsiKTsKCiAgICByZXR1cm4gbmFtZTsKICB9LAoKICAvLyBmaW5kIGZpcnN0IGgxIGVsZW1lbnQgaW4gRE9NIHRyZWUKICBmaW5kX2hlYWRpbmc6IGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPSAxKQogICAgICByZXR1cm4gbnVsbDsKCiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSAiSDEiIHx8IG5vZGUubm9kZU5hbWUgPT0gImgxIikKICAgICAgcmV0dXJuIG5vZGU7CgogICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOwoKICAgIHdoaWxlIChjaGlsZCkKICAgIHsKICAgICAgbm9kZSA9IHRoaXMuZmluZF9oZWFkaW5nKGNoaWxkKTsKCiAgICAgIGlmIChub2RlKQogICAgICAgIHJldHVybiBub2RlOwoKICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZzsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9LAoKICAvLyByZWN1cnNpdmVseSBleHRyYWN0IHRleHQgZnJvbSBET00gdHJlZQogIGV4dHJhY3RfdGV4dDogZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmICghbm9kZSkKICAgICAgcmV0dXJuICIiOwoKICAgIC8vIHRleHQgbm9kZXMKICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpCiAgICAgIHJldHVybiBub2RlLm5vZGVWYWx1ZTsKCiAgICAvLyBlbGVtZW50cwogICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkKICAgIHsKICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDsKICAgICAgdmFyIHRleHQgPSAiIjsKCiAgICAgIHdoaWxlIChub2RlKQogICAgICB7CiAgICAgICAgdGV4dCA9IHRleHQgKyB0aGlzLmV4dHJhY3RfdGV4dChub2RlKTsKICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRleHQ7CiAgICB9CgogICAgcmV0dXJuICIiOwogIH0sCgogIC8vIGZpbmQgY29weXJpZ2h0IHRleHQgZnJvbSBtZXRhIGVsZW1lbnQKICBmaW5kX2NvcHlyaWdodDogZnVuY3Rpb24gKCkgewogICAgdmFyIG5hbWUsIGNvbnRlbnQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiY29weXJpZ2h0IikKICAgICAgICByZXR1cm4gY29udGVudDsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9LAoKICBmaW5kX3NpemVfYWRqdXN0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgbmFtZSwgY29udGVudCwgb2Zmc2V0OwogICAgdmFyIG1ldGEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibWV0YSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgbmFtZSA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJuYW1lIik7CiAgICAgIGNvbnRlbnQgPSBtZXRhW2ldLmdldEF0dHJpYnV0ZSgiY29udGVudCIpOwoKICAgICAgaWYgKG5hbWUgPT0gImZvbnQtc2l6ZS1hZGp1c3RtZW50IikKICAgICAgICByZXR1cm4gMSAqIGNvbnRlbnQ7CiAgICB9CgogICAgcmV0dXJuIDE7CiAgfSwKCiAgLy8gPG1ldGEgbmFtZT0iZHVyYXRpb24iIGNvbnRlbnQ9IjIwIiAvPiAgZm9yIDIwIG1pbnV0ZXMKICBmaW5kX2R1cmF0aW9uOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgbmFtZSwgY29udGVudCwgb2Zmc2V0OwogICAgdmFyIG1ldGEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibWV0YSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgbmFtZSA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJuYW1lIik7CiAgICAgIGNvbnRlbnQgPSBtZXRhW2ldLmdldEF0dHJpYnV0ZSgiY29udGVudCIpOwoKICAgICAgaWYgKG5hbWUgPT0gImR1cmF0aW9uIikKICAgICAgICByZXR1cm4gNjAwMDAgKiBjb250ZW50OwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIHJlcGxhY2VfYnlfbm9uX2JyZWFraW5nX3NwYWNlOiBmdW5jdGlvbiAoc3RyKSB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkKICAgICAgc3RyW2ldID0gMTYwOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgaXMgdXNlIG9mICJsaSIgb2theSBmb3IgdGV4dC9odG1sPwogIC8vIGZvciBYSFRNTCBkbyB3ZSBhbHNvIG5lZWQgdG8gc3BlY2lmeSBuYW1lc3BhY2U/CiAgaW5pdF9vdXRsaW5lcjogZnVuY3Rpb24gKCkgewogICAgdmFyIGl0ZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImxpIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgdmFyIHRhcmdldCA9IGl0ZW1zW2ldOwoKICAgICAgaWYgKCF0aGlzLmhhc19jbGFzcyh0YXJnZXQucGFyZW50Tm9kZSwgIm91dGxpbmUiKSkKICAgICAgICBjb250aW51ZTsKCiAgICAgIHRhcmdldC5vbmNsaWNrID0gdGhpcy5vdXRsaW5lX2NsaWNrOwovKiAjIyMgbW9yZSB3b3JrIG5lZWRlZCBmb3IgSUU2CiAgICAgIGlmICghdGhpcy5uc19wb3MpCiAgICAgIHsKICAgICAgICB0YXJnZXQub25tb3VzZW92ZXIgPSB0aGlzLmhvdmVyX291dGxpbmU7CiAgICAgICAgdGFyZ2V0Lm9ubW91c2VvdXQgPSB0aGlzLnVuaG92ZXJfb3V0bGluZTsKICAgICAgfQoqLwogICAgICBpZiAodGhpcy5mb2xkYWJsZSh0YXJnZXQpKQogICAgICB7CiAgICAgICAgdGFyZ2V0LmZvbGRhYmxlID0gdHJ1ZTsKICAgICAgICB0YXJnZXQub25mb2N1cyA9IGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkub3V0bGluZSA9IHRoaXM7fTsKICAgICAgICB0YXJnZXQub25ibHVyID0gZnVuY3Rpb24gKCkge3czY19zbGlkeS5vdXRsaW5lID0gbnVsbDt9OwoKICAgICAgICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoInRhYmluZGV4IikpCiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsICIwIik7CgogICAgICAgIGlmICh0aGlzLmhhc19jbGFzcyh0YXJnZXQsICJleHBhbmQiKSkKICAgICAgICAgIHRoaXMudW5mb2xkKHRhcmdldCk7CiAgICAgICAgZWxzZQogICAgICAgICAgdGhpcy5mb2xkKHRhcmdldCk7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdGhpcy5hZGRfY2xhc3ModGFyZ2V0LCAibm9mb2xkIik7CiAgICAgICAgdGFyZ2V0LnZpc2libGUgPSB0cnVlOwogICAgICAgIHRhcmdldC5mb2xkYWJsZSA9IGZhbHNlOwogICAgICB9CiAgICB9CiAgfSwKCiAgZm9sZGFibGU6IGZ1bmN0aW9uIChpdGVtKSB7CiAgICBpZiAoIWl0ZW0gfHwgaXRlbS5ub2RlVHlwZSAhPSAxKQogICAgICByZXR1cm4gZmFsc2U7CgogICAgdmFyIG5vZGUgPSBpdGVtLmZpcnN0Q2hpbGQ7CgogICAgd2hpbGUgKG5vZGUpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgdGhpcy5pc19ibG9jayhub2RlKSkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9LAoKICAvLyAjIyMgQ0hFQ0sgTUUgIyMjIHN3aXRjaCB0byBhZGQvcmVtb3ZlICJoaWRkZW4iIGNsYXNzCiAgZm9sZDogZnVuY3Rpb24gKGl0ZW0pIHsKICAgIGlmIChpdGVtKQogICAgewogICAgICB0aGlzLnJlbW92ZV9jbGFzcyhpdGVtLCAidW5mb2xkZWQiKTsKICAgICAgdGhpcy5hZGRfY2xhc3MoaXRlbSwgImZvbGRlZCIpOwogICAgfQoKICAgIHZhciBub2RlID0gaXRlbSA/IGl0ZW0uZmlyc3RDaGlsZCA6IG51bGw7CgogICAgd2hpbGUgKG5vZGUpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgdGhpcy5pc19ibG9jayhub2RlKSkgLy8gZWxlbWVudAogICAgICB7CiAgICAgICAgIHczY19zbGlkeS5hZGRfY2xhc3Mobm9kZSwgImhpZGRlbiIpOwogICAgICB9CgogICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICBpdGVtLnZpc2libGUgPSBmYWxzZTsKICB9LAoKICAvLyAjIyMgQ0hFQ0sgTUUgIyMjIHN3aXRjaCB0byBhZGQvcmVtb3ZlICJoaWRkZW4iIGNsYXNzCiAgdW5mb2xkOiBmdW5jdGlvbiAoaXRlbSkgewogICAgaWYgKGl0ZW0pCiAgICB7CiAgICAgIHRoaXMuYWRkX2NsYXNzKGl0ZW0sICJ1bmZvbGRlZCIpOwogICAgICB0aGlzLnJlbW92ZV9jbGFzcyhpdGVtLCAiZm9sZGVkIik7CiAgICB9CgogICAgdmFyIG5vZGUgPSBpdGVtID8gaXRlbS5maXJzdENoaWxkIDogbnVsbDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKSAvLyBlbGVtZW50CiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKG5vZGUsICJoaWRkZW4iKTsKICAgICAgfQoKICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7CiAgICB9CgogICAgaXRlbS52aXNpYmxlID0gdHJ1ZTsKICB9LAoKICBvdXRsaW5lX2NsaWNrOiBmdW5jdGlvbiAoZSkgewogICAgaWYgKCFlKQogICAgICBlID0gd2luZG93LmV2ZW50OwoKICAgIHZhciByaWdodGNsaWNrID0gZmFsc2U7CiAgICB2YXIgdGFyZ2V0ID0gdzNjX3NsaWR5LmdldF90YXJnZXQoZSk7CgogICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQudmlzaWJsZSA9PSB1bmRlZmluZWQpCiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgIGlmICghdGFyZ2V0KQogICAgICByZXR1cm4gdHJ1ZTsKCiAgICBpZiAoZS53aGljaCkKICAgICAgcmlnaHRjbGljayA9IChlLndoaWNoID09IDMpOwogICAgZWxzZSBpZiAoZS5idXR0b24pCiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS5idXR0b24gPT0gMik7CgogICAgaWYgKCFyaWdodGNsaWNrICYmIHRhcmdldC52aXNpYmxlICE9IHVuZGVmaW5lZCkKICAgIHsKICAgICAgaWYgKHRhcmdldC5mb2xkYWJsZSkKICAgICAgewogICAgICAgIGlmICh0YXJnZXQudmlzaWJsZSkKICAgICAgICAgIHczY19zbGlkeS5mb2xkKHRhcmdldCk7CiAgICAgICAgZWxzZQogICAgICAgICAgdzNjX3NsaWR5LnVuZm9sZCh0YXJnZXQpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgICAgZS5jYW5jZWwgPSB0cnVlOwogICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIGFkZF9pbml0aWFsX3Byb21wdDogZnVuY3Rpb24gKCkgewogICAgdmFyIHByb21wdCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgcHJvbXB0LnNldEF0dHJpYnV0ZSgiY2xhc3MiLCAiaW5pdGlhbF9wcm9tcHQiKTsKCiAgICB2YXIgcDEgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJwIik7CiAgICBwcm9tcHQuYXBwZW5kQ2hpbGQocDEpOwogICAgcDEuc2V0QXR0cmlidXRlKCJjbGFzcyIsICJoZWxwIik7CgogICAgaWYgKHRoaXMua2V5Ym9hcmRsZXNzKQogICAgICBwMS5pbm5lckhUTUwgPSAic3dpcGUgbGVmdCB0byBtb3ZlIHRvIG5leHQgc2xpZGUiOwogICAgZWxzZQogICAgICBwMS5pbm5lckhUTUwgPSAiU3BhY2UsIFJpZ2h0IEFycm93IG9yIHN3aXBlIGxlZnQgdG8gbW92ZSB0byAiICsKICAgICAgICAgICAgICAgICAgICAgIm5leHQgc2xpZGUsIGNsaWNrIGhlbHAgYmVsb3cgZm9yIG1vcmUgZGV0YWlscyI7CgogICAgdGhpcy5hZGRfbGlzdGVuZXIocHJvbXB0LCAiY2xpY2siLCBmdW5jdGlvbiAoZSkgewogICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByb21wdCk7CiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgCiAgICAgIGlmIChlLmNhbmNlbCAhPSB1bmRlZmluZWQpCiAgICAgICAgZS5jYW5jZWwgPSB0cnVlOwogICAgICAKICAgICAgaWYgKGUucmV0dXJuVmFsdWUgIT0gdW5kZWZpbmVkKQogICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgICAgCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0pOwoKICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJvbXB0KTsKICAgIHRoaXMuaW5pdGlhbF9wcm9tcHQgPSBwcm9tcHQ7CiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocHJvbXB0KTt9LCA1MDAwKTsKICB9LAoKICBhZGRfdG9vbGJhcjogZnVuY3Rpb24gKCkgewogICAgdmFyIGNvdW50ZXIsIHBhZ2U7CgogICAgIHRoaXMudG9vbGJhciA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgIHRoaXMudG9vbGJhci5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgInRvb2xiYXIiKTsKCiAgICAgLy8gYSByZWFzb25hYmx5IGJlaGF2ZWQgYnJvd3NlcgogICAgIGlmICh0aGlzLm5zX3BvcyB8fCAhdGhpcy5pZTYpCiAgICAgewogICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICAgICByaWdodC5zZXRBdHRyaWJ1dGUoInN0eWxlIiwgImZsb2F0OiByaWdodDsgdGV4dC1hbGlnbjogcmlnaHQiKTsKCiAgICAgICBjb3VudGVyID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpCiAgICAgICBjb3VudGVyLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoInNsaWRlIikgKyAiIG4vbSI7CiAgICAgICByaWdodC5hcHBlbmRDaGlsZChjb3VudGVyKTsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChyaWdodCk7CgogICAgICAgdmFyIGxlZnQgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgICAgIGxlZnQuc2V0QXR0cmlidXRlKCJzdHlsZSIsICJ0ZXh0LWFsaWduOiBsZWZ0Iik7CgogICAgICAgLy8gZ2xvYmFsIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKICAgICAgIHRoaXMuZW9zID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpOwogICAgICAgdGhpcy5lb3MuaW5uZXJIVE1MID0gIiogIjsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQodGhpcy5lb3MpOwoKICAgICAgIHZhciBoZWxwID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiYSIpOwogICAgICAgaGVscC5zZXRBdHRyaWJ1dGUoImhyZWYiLCB0aGlzLmhlbHBfcGFnZSk7CiAgICAgICBoZWxwLnNldEF0dHJpYnV0ZSgidGl0bGUiLCB0aGlzLmxvY2FsaXplKHRoaXMuaGVscF90ZXh0KSk7CiAgICAgICBoZWxwLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoImhlbHA/Iik7CiAgICAgICBsZWZ0LmFwcGVuZENoaWxkKGhlbHApOwogICAgICAgdGhpcy5oZWxwX2FuY2hvciA9IGhlbHA7ICAvLyBzYXZlIGZvciBmb2N1cyBoYWNrCgogICAgICAgdmFyIGdhcDEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChnYXAxKTsKCiAgICAgICB2YXIgY29udGVudHMgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoImhyZWYiLCAiamF2YXNjcmlwdDp3M2Nfc2xpZHkudG9nZ2xlX3RhYmxlX29mX2NvbnRlbnRzKCkiKTsKICAgICAgIGNvbnRlbnRzLnNldEF0dHJpYnV0ZSgidGl0bGUiLCB0aGlzLmxvY2FsaXplKCJ0YWJsZSBvZiBjb250ZW50cyIpKTsKICAgICAgIGNvbnRlbnRzLmlubmVySFRNTCA9IHRoaXMubG9jYWxpemUoImNvbnRlbnRzPyIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChnYXAyKTsKCiAgICAgICB2YXIgY29weXJpZ2h0ID0gdGhpcy5maW5kX2NvcHlyaWdodCgpOwoKICAgICAgIGlmIChjb3B5cmlnaHQpCiAgICAgICB7CiAgICAgICAgIHZhciBzcGFuID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpOwogICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICJjb3B5cmlnaHQiOwogICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvcHlyaWdodDsKICAgICAgICAgbGVmdC5hcHBlbmRDaGlsZChzcGFuKTsKICAgICAgIH0KCiAgICAgICB0aGlzLnRvb2xiYXIuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsICIwIik7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQobGVmdCk7CiAgICAgfQogICAgIGVsc2UgLy8gSUU2IHNvIG5lZWQgdG8gd29yayBhcm91bmQgaXRzIHBvb3IgQ1NTIHN1cHBvcnQKICAgICB7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUucG9zaXRpb24gPSAodGhpcy5pZTcgPyAiZml4ZWQiIDogImFic29sdXRlIik7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUuekluZGV4ID0gIjIwMCI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUud2lkdGggPSAiOTkuOSUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmhlaWdodCA9ICIxLjJlbSI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUudG9wID0gImF1dG8iOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmJvdHRvbSA9ICIwIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5sZWZ0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnRleHRBbGlnbiA9ICJsZWZ0IjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5mb250U2l6ZSA9ICI2MCUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmNvbG9yID0gInJlZCI7CiAgICAgICB0aGlzLnRvb2xiYXIuYm9yZGVyV2lkdGggPSAwOwogICAgICAgdGhpcy50b29sYmFyLmNsYXNzTmFtZSA9ICJ0b29sYmFyIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIC8vIHdvdWxkIGxpa2UgdG8gaGF2ZSBoZWxwIHRleHQgbGVmdCBhbGlnbmVkCiAgICAgICAvLyBhbmQgcGFnZSBjb3VudGVyIHJpZ2h0IGFsaWduZWQsIGZsb2F0aW5nCiAgICAgICAvLyBkaXYncyBkb24ndCB3b3JrLCBzbyBpbnN0ZWFkIHVzZSBuZXN0ZWQKICAgICAgIC8vIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYncy4KCiAgICAgICB2YXIgc3AgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICBzcC5pbm5lckhUTUwgPSAiJm5ic3A7Jm5ic3A7KiZuYnNwOyI7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQoc3ApOwogICAgICAgdGhpcy5lb3MgPSBzcDsgIC8vIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKCiAgICAgICB2YXIgaGVscCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJocmVmIiwgdGhpcy5oZWxwX3BhZ2UpOwogICAgICAgaGVscC5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSh0aGlzLmhlbHBfdGV4dCkpOwogICAgICAgaGVscC5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJoZWxwPyIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGhlbHApOwogICAgICAgdGhpcy5oZWxwX2FuY2hvciA9IGhlbHA7ICAvLyBzYXZlIGZvciBmb2N1cyBoYWNrCgogICAgICAgdmFyIGdhcDEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDEpOwoKICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGNvbnRlbnRzLnNldEF0dHJpYnV0ZSgiaHJlZiIsICJqYXZhc2NyaXB0OnRvZ2dsZVRhYmxlT2ZDb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiLmxvY2FsaXplKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJjb250ZW50cz8iKTsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDIpOwoKICAgICAgIHZhciBjb3B5cmlnaHQgPSB0aGlzLmZpbmRfY29weXJpZ2h0KCk7CgogICAgICAgaWYgKGNvcHlyaWdodCkKICAgICAgIHsKICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gY29weXJpZ2h0OwogICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gImJsYWNrIjsKICAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gIjAuNWVtIjsKICAgICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHNwYW4pOwogICAgICAgfQoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKQogICAgICAgY291bnRlci5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICBjb3VudGVyLnN0eWxlLndpZHRoID0gImF1dG8iOyAvLyIyMCUiOwogICAgICAgY291bnRlci5zdHlsZS5oZWlnaHQgPSAiMS4yZW0iOwogICAgICAgY291bnRlci5zdHlsZS50b3AgPSAiYXV0byI7CiAgICAgICBjb3VudGVyLnN0eWxlLmJvdHRvbSA9IDA7CiAgICAgICBjb3VudGVyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgY291bnRlci5zdHlsZS50ZXh0QWxpZ24gPSAicmlnaHQiOwogICAgICAgY291bnRlci5zdHlsZS5jb2xvciA9ICJyZWQiOwogICAgICAgY291bnRlci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb3VudGVyKTsKICAgICB9CgogICAgIC8vIGVuc3VyZSB0aGF0IGNsaWNrIGlzbid0IHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBwYWdlCiAgICAgdGhpcy50b29sYmFyLm9uY2xpY2sgPQogICAgICAgICBmdW5jdGlvbiAoZSkgewogICAgICAgICAgIGlmICghZSkKICAgICAgICAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDsKCiAgICAgICAgICAgaWYgKCF0YXJnZXQgJiYgZS5zcmNFbGVtZW50KQogICAgICAgICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBTYWZhcmkgYnVnCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAiYSIpCiAgICAgICAgICAgICB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX2NsaWNrKGUpOwogICAgICAgICB9OwoKICAgICB0aGlzLnNsaWRlX251bWJlcl9lbGVtZW50ID0gY291bnRlcjsKICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKGZhbHNlKTsKICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9vbGJhcik7CiAgfSwKCiAgLy8gd3lzaXd5ZyBlZGl0b3JzIG1ha2UgaXQgaGFyZCB0byB1c2UgZGl2IGVsZW1lbnRzCiAgLy8gZS5nLiBhbWF5YSBsb3NlcyB0aGUgZGl2IHdoZW4geW91IGNvcHkgYW5kIHBhc3RlCiAgLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBkaXYgZWxlbWVudHMgYXJvdW5kIGltcGxpY2l0CiAgLy8gc2xpZGVzIHdoaWNoIHN0YXJ0IHdpdGggYW4gaDEgZWxlbWVudCBhbmQgY29udGludWUKICAvLyB1cCB0byB0aGUgbmV4dCBoZWFkaW5nIG9yIGRpdiBlbGVtZW50CiAgd3JhcF9pbXBsaWNpdF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpLCBoZWFkaW5nLCBub2RlLCBuZXh0LCBkaXY7CiAgICB2YXIgaGVhZGluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaDEiKTsKCiAgICBpZiAoIWhlYWRpbmdzKQogICAgICByZXR1cm47CgogICAgZm9yIChpID0gMDsgaSA8IGhlYWRpbmdzLmxlbmd0aDsgKytpKQogICAgewogICAgICBoZWFkaW5nID0gaGVhZGluZ3NbaV07CgogICAgICBpZiAoaGVhZGluZy5wYXJlbnROb2RlICE9IGRvY3VtZW50LmJvZHkpCiAgICAgICAgY29udGludWU7CgogICAgICBub2RlID0gaGVhZGluZy5uZXh0U2libGluZzsKCiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJzbGlkZSIpOwogICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZChkaXYsIGhlYWRpbmcpOwogICAgICBkaXYuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CgogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIC8vIGFuIGVsZW1lbnQKICAgICAgICB7CiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkgxIiB8fCBub2RlLm5vZGVOYW1lID09ICJoMSIpCiAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkRJViIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiZGl2IikKICAgICAgICAgICB7CiAgICAgICAgICAgICBpZiAodGhpcy5oYXNfY2xhc3Mobm9kZSwgInNsaWRlIikpCiAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhub2RlLCAiaGFuZG91dCIpKQogICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgICBub2RlID0gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub2RlKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7CiAgICAgICAgbm9kZSA9IG5leHQ7CiAgICAgIH0gCiAgICB9CiAgfSwKCiAgYXR0YWNoX3RvdWNoX2hhbmRlcnM6IGZ1bmN0aW9uKHNsaWRlcykKICB7CiAgICB2YXIgaSwgc2xpZGU7CgogICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgc2xpZGUgPSBzbGlkZXNbaV07CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2hzdGFydCIsIHRoaXMudG91Y2hzdGFydCk7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2htb3ZlIiwgdGhpcy50b3VjaG1vdmUpOwogICAgICB0aGlzLmFkZF9saXN0ZW5lcihzbGlkZSwgInRvdWNoZW5kIiwgdGhpcy50b3VjaGVuZCk7CiAgICB9CiAgfSwKCi8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIHNsaWRlcwogIGNvbGxlY3Rfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGVzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgInNsaWRlIikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgc2xpZGUgdG8gY29sbGVjdGlvbgogICAgICAgIHNsaWRlc1tzbGlkZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gaGlkZSBlYWNoIHNsaWRlIGFzIGl0IGlzIGZvdW5kCiAgICAgICAgdGhpcy5hZGRfY2xhc3MoZGl2LCAiaGlkZGVuIik7CgogICAgICAgIC8vIGFkZCBkdW1teSA8YnIvPiBhdCBlbmQgZm9yIHNjcm9sbGluZyBoYWNrCiAgICAgICAgdmFyIG5vZGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZTEpOwogICAgICAgIHZhciBub2RlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIik7CiAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5vZGUyKTsKICAgICAgfQogICAgICBlbHNlIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJiYWNrZ3JvdW5kIikpCiAgICAgIHsgIC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IFNWRyByZWxvYWQgYnVnCiAgICAgICAgLy8gd2hpY2ggb3RoZXJ3aXNlIHJlcGxhY2VzIDFzdCBTVkcgZ3JhcGhpYyB3aXRoIDJuZAogICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKICAgICAgfQogICAgfQoKICAgIHRoaXMuc2xpZGVzID0gc2xpZGVzOwogIH0sCgogIC8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIDxkaXYgY2xhc3M9ImhhbmRvdXQiPgogIGNvbGxlY3Rfbm90ZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBub3RlcyA9IG5ldyBBcnJheSgpOwogICAgdmFyIGRpdnMgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGRpdiA9IGRpdnMuaXRlbShpKTsKCiAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJoYW5kb3V0IikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgbm90ZSB0byBjb2xsZWN0aW9uCiAgICAgICAgbm90ZXNbbm90ZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gYW5kIGhpZGUgaXQKICAgICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJoaWRkZW4iKTsKICAgICAgfQogICAgfQoKICAgIHRoaXMubm90ZXMgPSBub3RlczsKICB9LAoKICAvLyByZXR1cm4gbmV3IGFycmF5IG9mIGFsbCA8ZGl2IGNsYXNzPSJiYWNrZ3JvdW5kIj4KICAvLyBpbmNsdWRpbmcgbmFtZWQgYmFja2dyb3VuZHMgZS5nLiBjbGFzcz0iYmFja2dyb3VuZCB0aXRsZXBhZ2UiCiAgY29sbGVjdF9iYWNrZ3JvdW5kczogZnVuY3Rpb24gKCkgewogICAgdmFyIGJhY2tncm91bmRzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgImJhY2tncm91bmQiKSkKICAgICAgewogICAgICAgIC8vIGFkZCBiYWNrZ3JvdW5kIHRvIGNvbGxlY3Rpb24KICAgICAgICBiYWNrZ3JvdW5kc1tiYWNrZ3JvdW5kcy5sZW5ndGhdID0gZGl2OwoKICAgICAgICAvLyBhbmQgaGlkZSBpdAogICAgICAgIHRoaXMuYWRkX2NsYXNzKGRpdiwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CgogICAgdGhpcy5iYWNrZ3JvdW5kcyA9IGJhY2tncm91bmRzOwogIH0sCgogIC8vIHNldCBjbGljayBoYW5kbGVycyBvbiBhbGwgYW5jaG9ycwogIHBhdGNoX2FuY2hvcnM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzZWxmID0gdzNjX3NsaWR5OwogICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgLy8gY29tcGFyZSB0aGlzLmhyZWYgd2l0aCBsb2NhdGlvbi5ocmVmCiAgICAgIC8vIGZvciBsaW5rIHRvIGFub3RoZXIgc2xpZGUgaW4gdGhpcyBkb2MKCiAgICAgIGlmIChzZWxmLnBhZ2VfYWRkcmVzcyh0aGlzLmhyZWYpID09IHNlbGYucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpKQogICAgICB7CiAgICAgICAgLy8geWVzLCBzbyBmaW5kIG5ldyBzbGlkZSBudW1iZXIKICAgICAgICB2YXIgbmV3c2xpZGVudW0gPSBzZWxmLmZpbmRfc2xpZGVfbnVtYmVyKHRoaXMuaHJlZik7CgogICAgICAgIGlmIChuZXdzbGlkZW51bSAhPSBzZWxmLnNsaWRlX251bWJlcikKICAgICAgICB7CiAgICAgICAgICB2YXIgc2xpZGUgPSBzZWxmLnNsaWRlc1tzZWxmLnNsaWRlX251bWJlcl07CiAgICAgICAgICBzZWxmLmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICAgc2VsZi5zbGlkZV9udW1iZXIgPSBuZXdzbGlkZW51bTsKICAgICAgICAgIHNsaWRlID0gc2VsZi5zbGlkZXNbc2VsZi5zbGlkZV9udW1iZXJdOwogICAgICAgICAgc2VsZi5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAgIHNlbGYuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UKICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihldmVudCk7CgovLyAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09IG51bGwpCi8vICAgICAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5ocmVmOwoKICAgICAgdGhpcy5ibHVyKCk7CiAgICAgIHNlbGYuZGlzYWJsZV9zbGlkZV9jbGljayA9IHRydWU7CiAgICB9OwoKICAgIHZhciBhbmNob3JzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9ycy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKQogICAgICAgIGFuY2hvcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBoYW5kbGVyLCBmYWxzZSk7CiAgICAgIGVsc2UKICAgICAgICBhbmNob3JzW2ldLmF0dGFjaEV2ZW50KCJvbmNsaWNrIiwgaGFuZGxlcik7CiAgICB9CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBzZWUgd2hpY2ggZnVuY3Rpb25zIGFyZSBpbnZva2VkIHZpYSBzZXRUaW1lb3V0CiAgLy8gZWl0aGVyIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgZm9yIHVzZSBvZiB3M2Nfc2xpZHkgdnMgdGhpcwogIHNob3dfc2xpZGVfbnVtYmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSB3M2Nfc2xpZHkuZ2V0X3RpbWVyKCk7CiAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyX2VsZW1lbnQuaW5uZXJIVE1MID0gdGltZXIgKyB3M2Nfc2xpZHkubG9jYWxpemUoInNsaWRlIikgKyAiICIgKwogICAgICAgICAgICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICsgMSkgKyAiLyIgKyB3M2Nfc2xpZHkuc2xpZGVzLmxlbmd0aDsKICB9LAoKICAvLyBldmVyeSAyMDBtUyBjaGVjayBpZiB0aGUgbG9jYXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhcyBhCiAgLy8gcmVzdWx0IG9mIHRoZSB1c2VyIGFjdGl2YXRpbmcgdGhlIEJhY2sgYnV0dG9uL21lbnUgaXRlbQogIC8vIGRvZXNuJ3Qgd29yayBmb3IgT3BlcmEgPCA5LjUKICBjaGVja19sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoOwoKICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID4gMCAmJiAoaGFzaCA9PSAiIiB8fCBoYXNoID09ICIjIikpCiAgICAgIHczY19zbGlkeS5nb3RvX3NsaWRlKDApOwogICAgZWxzZSBpZiAoaGFzaC5sZW5ndGggPiAyICYmIGhhc2ggIT0gIiMoIisodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSsiKSIpCiAgICB7CiAgICAgIHZhciBudW0gPSBwYXJzZUludChsb2NhdGlvbi5oYXNoLnN1YnN0cigyKSk7CgogICAgICBpZiAoIWlzTmFOKG51bSkpCiAgICAgICAgdzNjX3NsaWR5LmdvdG9fc2xpZGUobnVtLTEpOwogICAgfQoKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ICYmIHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgewogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ID4gMCkKICAgICAgICB3M2Nfc2xpZHkudGltZV9sZWZ0IC09IDIwMDsKICAgIH0gCiAgfSwKCiAgZ2V0X3RpbWVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSAiIjsKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0KQogICAgewogICAgICB2YXIgbWlucywgc2VjczsKICAgICAgc2VjcyA9IE1hdGguZmxvb3IodzNjX3NsaWR5LnRpbWVfbGVmdC8xMDAwKTsKICAgICAgbWlucyA9IE1hdGguZmxvb3Ioc2VjcyAvIDYwKTsKICAgICAgc2VjcyA9IHNlY3MgJSA2MDsKICAgICAgdGltZXIgPSAobWlucyA/IG1pbnMrIm0iIDogIiIpICsgc2VjcyArICJzICI7CiAgICB9CgogICAgcmV0dXJuIHRpbWVyOwogIH0sCgogIC8vIHRoaXMgZG9lc24ndCBwdXNoIGxvY2F0aW9uIG9udG8gaGlzdG9yeSBzdGFjayBmb3IgSUUKICAvLyBmb3Igd2hpY2ggYSBoaWRkZW4gaWZyYW1lIGhhY2sgaXMgbmVlZGVkOiBsb2FkIHBhZ2UgaW50bwogIC8vIHRoZSBpZnJhbWUgd2l0aCBzY3JpcHQgdGhhdCBzZXQncyBwYXJlbnQncyBsb2NhdGlvbi5oYXNoCiAgLy8gYnV0IHRoYXQgd29uJ3Qgd29yayBmb3Igc3RhbmRhbG9uZSB1c2UgdW5sZXNzIHdlIGNhbgogIC8vIGNyZWF0ZSB0aGUgcGFnZSBkeW5hbWljYWxseSB2aWEgYSBqYXZhc2NyaXB0OiBVUkwKICAvLyAjIyMgdXNlIGhpc3RvcnkucHVzaFN0YXRlIGlmIGF2YWlsYWJsZQogIHNldF9sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgIHZhciB1cmkgPSB3M2Nfc2xpZHkucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpOwogICAgIHZhciBoYXNoID0gIiMoIiArICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyKzEpICsgIikiOwoKICAgICBpZiAodzNjX3NsaWR5LnNsaWRlX251bWJlciA+PSAwKQogICAgICAgdXJpID0gdXJpICsgaGFzaDsKCiAgICAgaWYgKHR5cGVvZihoaXN0b3J5LnB1c2hTdGF0ZSkgIT0gInVuZGVmaW5lZCIpCiAgICAgewogICAgICAgZG9jdW1lbnQudGl0bGUgPSB3M2Nfc2xpZHkudGl0bGUgKyAiICgiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CiAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSgwLCBkb2N1bWVudC50aXRsZSwgaGFzaCk7CiAgICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICAgIHJldHVybjsKICAgICB9CgogICAgIGlmICh3M2Nfc2xpZHkuaWUgJiYgKHczY19zbGlkeS5pZTYgfHwgdzNjX3NsaWR5LmllNykpCiAgICAgICB3M2Nfc2xpZHkucHVzaF9oYXNoKGhhc2gpOwoKICAgICBpZiAodXJpICE9IGxvY2F0aW9uLmhyZWYpIC8vICYmICFraHRtbAogICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmk7CgogICAgIGlmICh0aGlzLmtodG1sKQogICAgICAgIGhhc2ggPSAiKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKCiAgICAgaWYgKCF0aGlzLmllICYmIGxvY2F0aW9uLmhhc2ggIT0gaGFzaCAmJiBsb2NhdGlvbi5oYXNoICE9ICIiKQogICAgICAgbG9jYXRpb24uaGFzaCA9IGhhc2g7CgogICAgIGRvY3VtZW50LnRpdGxlID0gdzNjX3NsaWR5LnRpdGxlICsgIiAoIiArICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyKzEpICsgIikiOwogICAgIHczY19zbGlkeS5zaG93X3NsaWRlX251bWJlcigpOwogIH0sCgogIHBhZ2VfYWRkcmVzczogZnVuY3Rpb24gKHVyaSkgewogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIGlmIChpIDwgMCkKICAgICAgaSA9IHVyaS5pbmRleE9mKCIlMjMiKTsKCiAgICAvLyBjaGVjayBpZiBhbmNob3IgaXMgZW50aXJlIHBhZ2UKCiAgICBpZiAoaSA8IDApCiAgICAgIHJldHVybiB1cmk7ICAvLyB5ZXMKCiAgICByZXR1cm4gdXJpLnN1YnN0cigwLCBpKTsKICB9LAoKICAvLyBvbmx5IHVzZWQgZm9yIElFNiBhbmQgSUU3CiAgb25fZnJhbWVfbG9hZGVkOiBmdW5jdGlvbiAoaGFzaCkgewogICAgbG9jYXRpb24uaGFzaCA9IGhhc2g7CiAgICB2YXIgdXJpID0gdzNjX3NsaWR5LnBhZ2VfYWRkcmVzcyhsb2NhdGlvbi5ocmVmKTsKICAgIGxvY2F0aW9uLmhyZWYgPSB1cmkgKyBoYXNoOwogIH0sCgogIC8vIGhpc3RvcnkgaGFjayB3aXRoIHRoYW5rcyB0byBCZXJ0cmFuZCBMZSBSb3kKICBwdXNoX2hhc2g6IGZ1bmN0aW9uIChoYXNoKSB7CiAgICBpZiAoaGFzaCA9PSAiIikgaGFzaCA9ICIjKDEpIjsKICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgIHZhciBkb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiaGlzdG9yeUZyYW1lIikuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgIGRvYy5vcGVuKCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+JyIpOwogICAgZG9jLndyaXRlKCI8aHRtbD48aGVhZD48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj53aW5kb3cucGFyZW50LnczY19zbGlkeS5vbl9mcmFtZV9sb2FkZWQoJyIrCiAgICAgIChoYXNoKSArICInKTs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+aGVsbG8gbXVtPC9ib2R5PjwvaHRtbD4iKTsKICAgICAgZG9jLmNsb3NlKCk7CiAgfSwKCiAgLy8gZmluZCBjdXJyZW50IHNsaWRlIGJhc2VkIHVwb24gbG9jYXRpb24KICAvLyBmaXJzdCBmaW5kIHRhcmdldCBhbmNob3IgYW5kIHRoZW4gbG9vawogIC8vIGZvciBhc3NvY2lhdGVkIGRpdiBlbGVtZW50IGVuY2xvc2luZyBpdAogIC8vIGZpbmFsbHkgbWFwIHRoYXQgdG8gc2xpZGUgbnVtYmVyCiAgZmluZF9zbGlkZV9udW1iZXI6IGZ1bmN0aW9uICh1cmkpIHsKICAgIC8vIGZpcnN0IGdldCBhbmNob3IgZnJvbSBwYWdlIGxvY2F0aW9uCgogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIC8vIGNoZWNrIGlmIGFuY2hvciBpcyBlbnRpcmUgcGFnZQogICAgaWYgKGkgPCAwKQogICAgICByZXR1cm4gMDsgIC8vIHllcwoKICAgIHZhciBhbmNob3IgPSB1bmVzY2FwZSh1cmkuc3Vic3RyKGkrMSkpOwoKICAgIC8vIG5vdyB1c2UgYW5jaG9yIGFzIFhNTCBJRCB0byBmaW5kIHRhcmdldAogICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvcik7CgogICAgaWYgKCF0YXJnZXQpCiAgICB7CiAgICAgIC8vIGRvZXMgYW5jaG9yIGxvb2sgbGlrZSAiKDIpIiBmb3Igc2xpZGUgMiA/PwogICAgICAvLyB3aGVyZSBmaXJzdCBzbGlkZSBpcyAoMSkKICAgICAgdmFyIHJlID0gL1woKFxkKStcKS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgIHZhciBudW0gPSBwYXJzZUludChhbmNob3Iuc3Vic3RyaW5nKDEsIGFuY2hvci5sZW5ndGgtMSkpOwoKICAgICAgICBpZiAobnVtID4gdGhpcy5zbGlkZXMubGVuZ3RoKQogICAgICAgICAgbnVtID0gMTsKCiAgICAgICAgaWYgKC0tbnVtIDwgMCkKICAgICAgICAgIG51bSA9IDA7CgogICAgICAgIHJldHVybiBudW07CiAgICAgIH0KCiAgICAgIC8vIGFjY2VwdCBbMl0gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5CiAgICAgIHJlID0gL1xbKFxkKStcXS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQoYW5jaG9yLnN1YnN0cmluZygxLCBhbmNob3IubGVuZ3RoLTEpKTsKCiAgICAgICAgIGlmIChudW0gPiB0aGlzLnNsaWRlcy5sZW5ndGgpCiAgICAgICAgICAgIG51bSA9IDE7CgogICAgICAgICBpZiAoLS1udW0gPCAwKQogICAgICAgICAgICBudW0gPSAwOwoKICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgfQoKICAgICAgLy8gb2ggZGVhciB1bmtub3duIGFuY2hvcgogICAgICByZXR1cm4gMDsKICAgIH0KCiAgICAvLyBzZWFyY2ggZm9yIGVuY2xvc2luZyBzbGlkZQoKICAgIHdoaWxlICh0cnVlKQogICAgewogICAgICAvLyBicm93c2VyIGNvZXJjZXMgaHRtbCBlbGVtZW50cyB0byB1cHBlcmNhc2UhCiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAiZGl2IiAmJgogICAgICAgICAgICB0aGlzLmhhc19jbGFzcyh0YXJnZXQsICJzbGlkZSIpKQogICAgICB7CiAgICAgICAgLy8gZm91bmQgdGhlIHNsaWRlIGVsZW1lbnQKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgLy8gb3RoZXJ3aXNlIHRyeSBwYXJlbnQgZWxlbWVudCBpZiBhbnkKCiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgaWYgKCF0YXJnZXQpCiAgICAgIHsKICAgICAgICByZXR1cm4gMDsgICAvLyBubyBsdWNrIQogICAgICB9CiAgICB9OwoKICAgIGZvciAoaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChzbGlkZXNbaV0gPT0gdGFyZ2V0KQogICAgICAgIHJldHVybiBpOyAgLy8gc3VjY2VzcwogICAgfQoKICAgIC8vIG9oIGRlYXIgc3RpbGwgbm8gbHVjawogICAgcmV0dXJuIDA7CiAgfSwKCiAgcHJldmlvdXNfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZTsKCiAgICAgIGlmICgoaW5jcmVtZW50YWwgfHwgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9PSAwKSAmJiB3M2Nfc2xpZHkubGFzdF9zaG93biAhPSBudWxsKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkuaGlkZV9wcmV2aW91c19pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoZmFsc2UpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKCiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgLSAxOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICBpZiAoIXczY19zbGlkeS5uc19wb3MpCiAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgfQogIH0sCgogIG5leHRfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZSwgbGFzdCA9IHczY19zbGlkeS5sYXN0X3Nob3duOwoKICAgICAgaWYgKGluY3JlbWVudGFsIHx8IHczY19zbGlkeS5zbGlkZV9udW1iZXIgPT0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5yZXZlYWxfbmV4dF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKCiAgICAgIGlmICgoIWluY3JlbWVudGFsIHx8IHczY19zbGlkeS5sYXN0X3Nob3duID09IG51bGwpICYmCiAgICAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgKyAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlIGlmICghdzNjX3NsaWR5Lmxhc3Rfc2hvd24pCiAgICAgIHsKICAgICAgICAgaWYgKGxhc3QgJiYgaW5jcmVtZW50YWwpCiAgICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBsYXN0OwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgIH0KICB9LAoKICAvLyB0byBmaXJzdCBzbGlkZSB3aXRoIG5vdGhpbmcgcmV2ZWFsZWQKICAvLyBpLmUuIHN0YXRlIGF0IHN0YXJ0IG9mIHByZXNlbnRhdGlvbgogIGZpcnN0X3NsaWRlOiBmdW5jdGlvbiAoKSB7CiAgICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgewogICAgICAgdmFyIHNsaWRlOwoKICAgICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICE9IDApCiAgICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IDA7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgfQoKICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cygKICAgICAgICAgIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKICAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgICB9CiAgfSwKCiAgLy8gZ290byBsYXN0IHNsaWRlIHdpdGggZXZlcnl0aGluZyByZXZlYWxlZAogIC8vIGkuZS4gc3RhdGUgYXQgZW5kIG9mIHByZXNlbnRhdGlvbgogIGxhc3Rfc2xpZGU6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICB2YXIgc2xpZGU7CgogICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7IC8vcmV2ZWFsTmV4dEl0ZW0obGFzdFNob3duKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkubGFzdF9zaG93biA9PSBudWxsICYmCiAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKCiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgidmlzaWJsZSIpOwogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgIH0KICB9LAoKCiAgLy8gIyMjIGNoZWNrIHRoaXMgYW5kIGNvbnNpZGVyIGFkZC9yZW1vdmUgY2xhc3MKICBzZXRfZW9zX3N0YXR1czogZnVuY3Rpb24gKHN0YXRlKSB7CiAgICBpZiAodGhpcy5lb3MpCiAgICAgIHRoaXMuZW9zLnN0eWxlLmNvbG9yID0gKHN0YXRlID8gInJnYigyNDAsMjQwLDI0MCkiIDogInJlZCIpOwogIH0sCgogIC8vIGZpcnN0IHNsaWRlIGlzIDAKICBnb3RvX3NsaWRlOiBmdW5jdGlvbiAobnVtKSB7CiAgICAvL2FsZXJ0KCJnb2luZyB0byBzbGlkZSAiICsgKG51bSsxKSk7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IG51bTsKICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlX251bWJlcigpOwogIH0sCgoKICBzaG93X3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuc3luY19iYWNrZ3JvdW5kKHNsaWRlKTsKICAgIHRoaXMucmVtb3ZlX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CgogICAgLy8gd29yayBhcm91bmQgSUU5IG9iamVjdCByZW5kZXJpbmcgYnVnCiAgICBzZXRUaW1lb3V0KCJ3aW5kb3cuc2Nyb2xsVG8oMCwwKTsiLCAxKTsKICB9LAoKICBoaWRlX3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuYWRkX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CiAgfSwKCiAgLy8gc2hvdyBqdXN0IHRoZSBiYWNrZ3JvdW5kcyBwZXJ0aW5lbnQgdG8gdGhpcyBzbGlkZQogIC8vIHdoZW4gc2xpZGUgYmFja2dyb3VuZC1jb2xvciBpcyB0cmFuc3BhcmVudAogIC8vIHRoaXMgc2hvdWxkIG5vdyB3b3JrIHdpdGggcmdiYSBjb2xvciB2YWx1ZXMKICBzeW5jX2JhY2tncm91bmQ6IGZ1bmN0aW9uIChzbGlkZSkgewogICAgdmFyIGJhY2tncm91bmQ7CiAgICB2YXIgYmdDb2xvcjsKCiAgICBpZiAoc2xpZGUuY3VycmVudFN0eWxlKQogICAgICBiZ0NvbG9yID0gc2xpZGUuY3VycmVudFN0eWxlWyJiYWNrZ3JvdW5kQ29sb3IiXTsKICAgIGVsc2UgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3KQogICAgewogICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSxudWxsKTsKCiAgICAgIGlmIChzdHlsZXMpCiAgICAgICAgYmdDb2xvciA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIik7CiAgICAgIGVsc2UgLy8gYnJva2VuIGltcGxlbWVudGF0aW9uIHByb2JhYmx5IGR1ZSBTYWZhcmkgb3IgS29ucXVlcm9yCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJkZWZlY3RpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2V0Q29tcHV0ZWRTdHlsZSgpIik7CiAgICAgICAgYmdDb2xvciA9ICJ0cmFuc3BhcmVudCI7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgICAgYmdDb2xvciA9PSAidHJhbnNwYXJlbnQiOwoKICAgIGlmIChiZ0NvbG9yID09ICJ0cmFuc3BhcmVudCIgfHwKICAgICAgICBiZ0NvbG9yLmluZGV4T2YoInJnYmEiKSA+PSAwIHx8CiAgICAgICAgYmdDb2xvci5pbmRleE9mKCJvcGFjaXR5IikgPj0gMCkKICAgIHsKICAgICAgdmFyIHNsaWRlQ2xhc3MgPSB0aGlzLmdldF9jbGFzc19saXN0KHNsaWRlKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgICAgewogICAgICAgIGJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRzW2ldOwoKICAgICAgICB2YXIgYmdDbGFzcyA9IHRoaXMuZ2V0X2NsYXNzX2xpc3QoYmFja2dyb3VuZCk7CgogICAgICAgIGlmICh0aGlzLm1hdGNoaW5nX2JhY2tncm91bmQoc2xpZGVDbGFzcywgYmdDbGFzcykpCiAgICAgICAgICB0aGlzLnJlbW92ZV9jbGFzcyhiYWNrZ3JvdW5kLCAiaGlkZGVuIik7CiAgICAgICAgZWxzZQogICAgICAgICAgdGhpcy5hZGRfY2xhc3MoYmFja2dyb3VuZCwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CiAgICBlbHNlIC8vIGZvcmNpYmx5IGhpZGUgYWxsIGJhY2tncm91bmRzCiAgICAgIHRoaXMuaGlkZV9iYWNrZ3JvdW5kcygpOwogIH0sCgogIGhpZGVfYmFja2dyb3VuZHM6IGZ1bmN0aW9uICgpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZHNbaV07CiAgICAgIHRoaXMuYWRkX2NsYXNzKGJhY2tncm91bmQsICJoaWRkZW4iKTsKICAgIH0KICB9LAoKICAvLyBjb21wYXJlIGNsYXNzZXMgZm9yIHNsaWRlIGFuZCBiYWNrZ3JvdW5kCiAgbWF0Y2hpbmdfYmFja2dyb3VuZDogZnVuY3Rpb24gKHNsaWRlQ2xhc3MsIGJnQ2xhc3MpIHsKICAgIHZhciBpLCBjb3VudCwgcGF0dGVybiwgcmVzdWx0OwoKICAgIC8vIGRlZmluZSBwYXR0ZXJuIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgcGF0dGVybiA9IC9cdysvZzsKCiAgICAvLyBjaGVjayBiYWNrZ3JvdW5kIGNsYXNzIG5hbWVzCiAgICByZXN1bHQgPSBiZ0NsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIGZvciAoaSA9IGNvdW50ID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgaWYgKHJlc3VsdFtpXSA9PSAiaGlkZGVuIikKICAgICAgICBjb250aW51ZTsKCiAgICAgIGlmIChyZXN1bHRbaV0gPT0gImJhY2tncm91bmQiKQoJY29udGludWU7CgogICAgICArK2NvdW50OwogICAgfQoKICAgIGlmIChjb3VudCA9PSAwKSAgLy8gZGVmYXVsdCBtYXRjaAogICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcyBhbmQgcGxhY2UgcmVzdWx0IGluIGFycmF5CiAgICByZXN1bHQgPSBzbGlkZUNsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIG5hbWUgaXMgcHJlc2VudCBmb3IgYmFja2dyb3VuZAogICAgZm9yIChpID0gY291bnQgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKQogICAgewogICAgICBpZiAocmVzdWx0W2ldID09ICJoaWRkZW4iKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgaWYgKHRoaXMuaGFzX3Rva2VuKGJnQ2xhc3MsIHJlc3VsdFtpXSkpCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIHJlc2l6ZWQ6IGZ1bmN0aW9uICgpIHsKICAgICB2YXIgd2lkdGggPSAwOwoKICAgICBpZiAoIHR5cGVvZiggd2luZG93LmlubmVyV2lkdGggKSA9PSAnbnVtYmVyJyApCiAgICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoOyAgLy8gTm9uIElFIGJyb3dzZXIKICAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKQogICAgICAgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7ICAvLyBJRTYKICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpCiAgICAgICB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7IC8vIElFNAoKICAgICB2YXIgaGVpZ2h0ID0gMDsKCiAgICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lckhlaWdodCApID09ICdudW1iZXInICkKICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgIC8vIE5vbiBJRSBicm93c2VyCiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpCiAgICAgICBoZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyAgLy8gSUU2CiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgIGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKCiAgICAgaWYgKGhlaWdodCAmJiAod2lkdGgvaGVpZ2h0ID4gMS4wNSoxMDI0Lzc2OCkpCiAgICAgewogICAgICAgd2lkdGggPSBoZWlnaHQgKiAxMDI0LjAvNzY4OwogICAgIH0KCiAgICAgLy8gSUUgZmlyZXMgb25yZXNpemUgZXZlbiB3aGVuIG9ubHkgZm9udCBzaXplIGlzIGNoYW5nZWQhCiAgICAgLy8gc28gd2UgZG8gYSBjaGVjayB0byBhdm9pZCBibG9ja2luZyA8IGFuZCA+IGFjdGlvbnMKICAgICBpZiAod2lkdGggIT0gdzNjX3NsaWR5Lmxhc3Rfd2lkdGggfHwgaGVpZ2h0ICE9IHczY19zbGlkeS5sYXN0X2hlaWdodCkKICAgICB7CiAgICAgICBpZiAod2lkdGggPj0gMTEwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSA1OyAgICAvLyA0CiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSAxMDAwKQogICAgICAgICB3M2Nfc2xpZHkuc2l6ZV9pbmRleCA9IDQ7ICAgIC8vIDMKICAgICAgIGVsc2UgaWYgKHdpZHRoID49IDgwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSAzOyAgICAvLyAyCiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSA2MDApCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMjsgICAgLy8gMQogICAgICAgZWxzZSBpZiAod2lkdGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMDsKCiAgICAgICAvLyBhZGQgaW4gZm9udCBzaXplIGFkanVzdG1lbnQgZnJvbSBtZXRhIGVsZW1lbnQgZS5nLgogICAgICAgLy8gPG1ldGEgbmFtZT0iZm9udC1zaXplLWFkanVzdG1lbnQiIGNvbnRlbnQ9Ii0yIiAvPgogICAgICAgLy8gdXNlZnVsIHdoZW4gc2xpZGVzIGhhdmUgdG9vIG11Y2ggY29udGVudCA7LSkKCiAgICAgICBpZiAoMCA8PSB3M2Nfc2xpZHkuc2l6ZV9pbmRleCArIHczY19zbGlkeS5zaXplX2FkanVzdG1lbnQgJiYKICAgICAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ICsgdzNjX3NsaWR5LnNpemVfYWRqdXN0bWVudCA8IHczY19zbGlkeS5zaXplcy5sZW5ndGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gdzNjX3NsaWR5LnNpemVfaW5kZXggKyB3M2Nfc2xpZHkuc2l6ZV9hZGp1c3RtZW50OwoKICAgICAgIC8vIGVuYWJsZXMgY3Jvc3MgYnJvd3NlciB1c2Ugb2YgcmVsYXRpdmUgd2lkdGgvaGVpZ2h0CiAgICAgICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAgICAgIHczY19zbGlkeS5hZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7CgogICAgICAgaWYgKGRvY3VtZW50LmJvZHkuc3R5bGUuZm9udFNpemUgIT0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XSkKICAgICAgIHsKICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICAgICB9CgogICAgICAgdzNjX3NsaWR5Lmxhc3Rfd2lkdGggPSB3aWR0aDsKICAgICAgIHczY19zbGlkeS5sYXN0X2hlaWdodCA9IGhlaWdodDsKCiAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gd29yayBhcm91bmQgTW96aWxsYSBidWcKICAgICAgIGlmICh3M2Nfc2xpZHkubnNfcG9zKQogICAgICAgewogICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgIH0KCiAgICAgICAvLyBmb3JjZSBjb3JyZWN0IHBvc2l0aW9uaW5nIG9mIHRvb2xiYXIKICAgICAgIHczY19zbGlkeS5yZWZyZXNoX3Rvb2xiYXIoMjAwKTsKICAgICB9CiAgfSwKCiAgc2Nyb2xsZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkudG9vbGJhciAmJiAhdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhhY2tfb2Zmc2V0ID0gdzNjX3NsaWR5LnNjcm9sbF94X29mZnNldCgpOwogICAgICAvLyBoaWRlIHRvb2xiYXIKICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKCiAgICAgIC8vIG1ha2UgaXQgcmVhcHBlYXIgbGF0ZXIKICAgICAgaWYgKHczY19zbGlkeS5zY3JvbGxoYWNrID09IDAgJiYgIXczY19zbGlkeS52aWV3X2FsbCkKICAgICAgewogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge3czY19zbGlkeS5zaG93X3Rvb2xiYXIoKTsgfSwgMTAwMCk7CiAgICAgICAgdzNjX3NsaWR5LnNjcm9sbGhhY2sgPSAxOwogICAgICB9CiAgICB9CiAgfSwKCiAgaGlkZV90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIik7CiAgICB3aW5kb3cuZm9jdXMoKTsKICB9LAoKICAvLyB1c2VkIHRvIGVuc3VyZSBJRSByZWZyZXNoZXMgdG9vbGJhciBpbiBjb3JyZWN0IHBvc2l0aW9uCiAgcmVmcmVzaF90b29sYmFyOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHsKICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhpZGVfdG9vbGJhcigpOwogICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7fSwgaW50ZXJ2YWwpOwogICAgfQogIH0sCgogIC8vIHJlc3RvcmVzIHRvb2xiYXIgYWZ0ZXIgc2hvcnQgZGVsYXkKICBzaG93X3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkud2FudF90b29sYmFyKQogICAgewogICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgewogICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbiB0byBhbGxvdyBmb3Igc2Nyb2xsaW5nCiAgICAgICAgdmFyIHhvZmZzZXQgPSB3M2Nfc2xpZHkuc2Nyb2xsX3hfb2Zmc2V0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUubGVmdCA9IHhvZmZzZXQ7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUucmlnaHQgPSB4b2Zmc2V0OwoKICAgICAgICAvLyBkZXRlcm1pbmUgdmVydGljYWwgc2Nyb2xsIG9mZnNldAogICAgICAgIC8vdmFyIHlvZmZzZXQgPSBzY3JvbGxZT2Zmc2V0KCk7CgogICAgICAgIC8vIGJvdHRvbSBpcyBkb2MgaGVpZ2h0IC0gd2luZG93IGhlaWdodCAtIHNjcm9sbCBvZmZzZXQKICAgICAgICAvL3ZhciBib3R0b20gPSBkb2N1bWVudEhlaWdodCgpIC0gbGFzdEhlaWdodCAtIHlvZmZzZXQKCiAgICAgICAgLy9pZiAoeW9mZnNldCA+IDAgfHwgZG9jdW1lbnRIZWlnaHQoKSA+IGxhc3RIZWlnaHQpCiAgICAgICAgLy8gICBib3R0b20gKz0gMTY7ICAvLyBhbGxvdyBmb3IgaGVpZ2h0IG9mIHNjcm9sbGJhcgoKICAgICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5ib3R0b20gPSAwOyAvL2JvdHRvbTsKICAgICAgfQoKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpOwogICAgfQoKICAgIHczY19zbGlkeS5zY3JvbGxoYWNrID0gMDsKCgogICAgLy8gc2V0IHRoZSBrZXlib2FyZCBmb2N1cyB0byB0aGUgaGVscCBsaW5rIG9uIHRoZQogICAgLy8gdG9vbGJhciB0byBlbnN1cmUgdGhhdCBkb2N1bWVudCBoYXMgdGhlIGZvY3VzCiAgICAvLyBJRSBkb2Vzbid0IGFsd2F5cyB3b3JrIHdpdGggd2luZG93LmZvY3VzKCkKICAgIC8vIGFuZCB0aGlzIGhhY2sgaGFzIGJlbmVmaXQgb2YgRW50ZXIgZm9yIGhlbHAKCiAgICB0cnkKICAgIHsKICAgICAgaWYgKCF3M2Nfc2xpZHkub3BlcmEpCiAgICAgICAgdzNjX3NsaWR5LmhlbHBfYW5jaG9yLmZvY3VzKCk7CiAgICB9CiAgICBjYXRjaCAoZSkKICAgIHsKICAgIH0KICB9LAoKLy8gaW52b2tlZCB2aWEgRiBrZXkKICB0b2dnbGVfdG9vbGJhcjogZnVuY3Rpb24gKCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkuaGFzX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIikpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIikKICAgICAgICB3M2Nfc2xpZHkud2FudF90b29sYmFyID0gMTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIikKICAgICAgICB3M2Nfc2xpZHkud2FudF90b29sYmFyID0gMDsKICAgICAgfQogICAgfQogIH0sCgogIHNjcm9sbF94X29mZnNldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHdpbmRvdy5wYWdlWE9mZnNldCkKICAgICAgcmV0dXJuIHNlbGYucGFnZVhPZmZzZXQ7CgogICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAKICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KQogICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7CgogICAgaWYgKGRvY3VtZW50LmJvZHkpCiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7CgogICAgcmV0dXJuIDA7CiAgfSwKCiAgc2Nyb2xsX3lfb2Zmc2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0KQogICAgICByZXR1cm4gc2VsZi5wYWdlWU9mZnNldDsKCiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIAogICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7CgogICAgaWYgKGRvY3VtZW50LmJvZHkpCiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDsKCiAgICByZXR1cm4gMDsKICB9LAoKICAvLyBsb29raW5nIGZvciBhIHdheSB0byBkZXRlcm1pbmUgaGVpZ2h0IG9mIHNsaWRlIGNvbnRlbnQKICAvLyB0aGUgc2xpZGUgaXRzZWxmIGlzIHNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3cKICBvcHRpbWl6ZV9mb250X3NpemU6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CgogICAgLy92YXIgZGggPSBkb2N1bWVudEhlaWdodCgpOyAvL2dldERvY0hlaWdodChkb2N1bWVudCk7CiAgICB2YXIgZGggPSBzbGlkZS5zY3JvbGxIZWlnaHQ7CiAgICB2YXIgd2ggPSBnZXRXaW5kb3dIZWlnaHQoKTsKICAgIHZhciB1ID0gMTAwICogZGggLyB3aDsKCiAgICBhbGVydCgid2luZG93IHV0aWxpemF0aW9uID0gIiArIHUgKyAiJSAoZG9jICIKICAgICAgKyBkaCArICIgd2luICIgKyB3aCArICIpIik7CiAgfSwKCiAgLy8gZnJvbSBkb2N1bWVudCBvYmplY3QKICBnZXRfZG9jX2hlaWdodDogZnVuY3Rpb24gKGRvYykgewogICAgaWYgKCFkb2MpCiAgICAgIGRvYyA9IGRvY3VtZW50OwoKICAgIGlmIChkb2MgJiYgZG9jLmJvZHkgJiYgZG9jLmJvZHkub2Zmc2V0SGVpZ2h0KQogICAgICByZXR1cm4gZG9jLmJvZHkub2Zmc2V0SGVpZ2h0OyAgLy8gbnMvZ2Vja28gc3ludGF4CgogICAgaWYgKGRvYyAmJiBkb2MuYm9keSAmJiBkb2MuYm9keS5zY3JvbGxIZWlnaHQpCiAgICAgIHJldHVybiBkb2MuYm9keS5zY3JvbGxIZWlnaHQ7CgogICAgYWxlcnQoImNvdWxkbid0IGRldGVybWluZSBkb2N1bWVudCBoZWlnaHQiKTsKICB9LAoKICBnZXRfd2luZG93X2hlaWdodDogZnVuY3Rpb24gKCkgewogICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lckhlaWdodCApID09ICdudW1iZXInICkKICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDsgIC8vIE5vbiBJRSBicm93c2VyCgogICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KQogICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDsgIC8vIElFNgoKICAgIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7IC8vIElFNAogIH0sCgogIGRvY3VtZW50X2hlaWdodDogZnVuY3Rpb24gKCkgewogICAgdmFyIHNoLCBvaDsKCiAgICBzaCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0OwogICAgb2ggPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDsKCiAgICBpZiAoc2ggJiYgb2gpCiAgICB7CiAgICAgIHJldHVybiAoc2ggPiBvaCA/IHNoIDogb2gpOwogICAgfQoKICAgIC8vIG5vIGlkZWEhCiAgICByZXR1cm4gMDsKICB9LAoKICBzbWFsbGVyOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodzNjX3NsaWR5LnNpemVfaW5kZXggPiAwKQogICAgewogICAgICAtLXczY19zbGlkeS5zaXplX2luZGV4OwogICAgfQoKICAgIHczY19zbGlkeS50b29sYmFyLnN0eWxlLmRpc3BsYXkgPSAibm9uZSI7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmZvbnRTaXplID0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XTsKICAgIHZhciBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZShzbGlkZSk7CiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7IH0sIDUwKTsKICB9LAoKICBiaWdnZXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkuc2l6ZV9pbmRleCA8IHczY19zbGlkeS5zaXplcy5sZW5ndGggLSAxKQogICAgewogICAgICArK3czY19zbGlkeS5zaXplX2luZGV4OwogICAgfQoKICAgIHczY19zbGlkeS50b29sYmFyLnN0eWxlLmRpc3BsYXkgPSAibm9uZSI7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmZvbnRTaXplID0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XTsKICAgIHZhciBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZShzbGlkZSk7CiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7IH0sIDUwKTsKICB9LAoKICAvLyBlbmFibGVzIGNyb3NzIGJyb3dzZXIgdXNlIG9mIHJlbGF0aXZlIHdpZHRoL2hlaWdodAogIC8vIG9uIG9iamVjdCBlbGVtZW50cyBmb3IgdXNlIHdpdGggU1ZHIGFuZCBGbGFzaCBtZWRpYQogIC8vIHdpdGggdGhhbmtzIHRvIEl2YW4gSGVybWFuIGZvciB0aGUgc3VnZ2VzdGlvbgogIGFkanVzdF9vYmplY3RfZGltZW5zaW9uczogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHsKICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdzNjX3NsaWR5Lm9iamVjdHMubGVuZ3RoOyBpKysgKQogICAgewogICAgICB2YXIgb2JqID0gdGhpcy5vYmplY3RzW2ldOwogICAgICB2YXIgbWltZVR5cGUgPSBvYmouZ2V0QXR0cmlidXRlKCJ0eXBlIik7CgogICAgICBpZiAobWltZVR5cGUgPT0gImltYWdlL3N2Zyt4bWwiIHx8IG1pbWVUeXBlID09ICJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCIpCiAgICAgIHsKICAgICAgICBpZiAoICFvYmouaW5pdGlhbFdpZHRoICkgCiAgICAgICAgICBvYmouaW5pdGlhbFdpZHRoID0gb2JqLmdldEF0dHJpYnV0ZSgid2lkdGgiKTsKCiAgICAgICAgaWYgKCAhb2JqLmluaXRpYWxIZWlnaHQgKSAKICAgICAgICAgIG9iai5pbml0aWFsSGVpZ2h0ID0gb2JqLmdldEF0dHJpYnV0ZSgiaGVpZ2h0Iik7CgogICAgICAgIGlmICggb2JqLmluaXRpYWxXaWR0aCAmJiBvYmouaW5pdGlhbFdpZHRoLmNoYXJBdChvYmouaW5pdGlhbFdpZHRoLmxlbmd0aC0xKSA9PSAiJSIgKQogICAgICAgIHsKICAgICAgICAgIHZhciB3ID0gcGFyc2VJbnQob2JqLmluaXRpYWxXaWR0aC5zbGljZSgwLCBvYmouaW5pdGlhbFdpZHRoLmxlbmd0aC0xKSk7CiAgICAgICAgICB2YXIgbmV3VyA9IHdpZHRoICogKHcvMTAwLjApOwogICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZSgid2lkdGgiLG5ld1cpOwogICAgICAgIH0KCiAgICAgICAgaWYgKCBvYmouaW5pdGlhbEhlaWdodCAmJgogICAgICAgICAgICAgb2JqLmluaXRpYWxIZWlnaHQuY2hhckF0KG9iai5pbml0aWFsSGVpZ2h0Lmxlbmd0aC0xKSA9PSAiJSIgKQogICAgICAgIHsKICAgICAgICAgIHZhciBoID0gcGFyc2VJbnQob2JqLmluaXRpYWxIZWlnaHQuc2xpY2UoMCwgb2JqLmluaXRpYWxIZWlnaHQubGVuZ3RoLTEpKTsKICAgICAgICAgIHZhciBuZXdIID0gaGVpZ2h0ICogKGgvMTAwLjApOwogICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IiwgbmV3SCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSwKCiAgLy8gbmVlZGVkIGZvciBPcGVyYSB0byBpbmhpYml0IGRlZmF1bHQgYmVoYXZpb3IKICAvLyBzaW5jZSBPcGVyYSBkZWxpdmVycyBrZXlQcmVzcyBldmVuIGlmIGtleURvd24KICAvLyB3YXMgY2FuY2VsbGVkCiAga2V5X3ByZXNzOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGlmICghZXZlbnQpCiAgICAgIGV2ZW50ID0gd2luZG93LmV2ZW50OwoKICAgIGlmICghdzNjX3NsaWR5LmtleV93YW50ZWQpCiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICAvLyAgU2VlIGUuZy4gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHMva2V5cy5odG1sIGZvciBrZXljb2RlcwogIGtleV9kb3duOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIHZhciBrZXksIHRhcmdldCwgdGFnOwoKICAgIHczY19zbGlkeS5rZXlfd2FudGVkID0gdHJ1ZTsKCiAgICBpZiAoIWV2ZW50KQogICAgICBldmVudCA9IHdpbmRvdy5ldmVudDsKCiAgICAvLyBrbHVkZ2UgYXJvdW5kIE5TL0lFIGRpZmZlcmVuY2VzIAogICAgaWYgKHdpbmRvdy5ldmVudCkKICAgIHsKICAgICAga2V5ID0gd2luZG93LmV2ZW50LmtleUNvZGU7CiAgICAgIHRhcmdldCA9IHdpbmRvdy5ldmVudC5zcmNFbGVtZW50OwogICAgfQogICAgZWxzZSBpZiAoZXZlbnQud2hpY2gpCiAgICB7CiAgICAgIGtleSA9IGV2ZW50LndoaWNoOwogICAgICB0YXJnZXQgPSBldmVudC50YXJnZXQ7CiAgICB9CiAgICBlbHNlCiAgICAgIHJldHVybiB0cnVlOyAvLyBZaWtlcyEgdW5rbm93biBicm93c2VyCgogICAgLy8gaWdub3JlIGV2ZW50IGlmIGtleSB2YWx1ZSBpcyB6ZXJvCiAgICAvLyBhcyBmb3IgYWx0IG9uIE9wZXJhIGFuZCBLb25xdWVyb3IKICAgIGlmICgha2V5KQogICAgICAgcmV0dXJuIHRydWU7CgogICAgLy8gYXZvaWQgaW50ZXJmZXJpbmcgd2l0aCBrZXlzdHJva2UKICAgIC8vIGJlaGF2aW9yIGZvciBub24tc2xpZHkgY2hyb21lIGVsZW1lbnRzCiAgICBpZiAoIXczY19zbGlkeS5zbGlkeV9jaHJvbWUodGFyZ2V0KSAmJgogICAgICAgIHczY19zbGlkeS5zcGVjaWFsX2VsZW1lbnQodGFyZ2V0KSkKICAgICAgcmV0dXJuIHRydWU7CgogICAgLy8gY2hlY2sgZm9yIGNvbmN1cnJlbnQgY29udHJvbC9jb21tYW5kL2FsdCBrZXkKICAgIC8vIGJ1dCBhcmUgdGhlc2Ugb25seSBwcmVzZW50IG9uIG1vdXNlIGV2ZW50cz8KCiAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkKICAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGRpc21pc3MgdGFibGUgb2YgY29udGVudHMgaWYgdmlzaWJsZQogICAgaWYgKHczY19zbGlkeS5pc19zaG93bl90b2MoKSAmJiBrZXkgIT0gOSAmJiBrZXkgIT0gMTYgJiYga2V5ICE9IDM4ICYmIGtleSAhPSA0MCkKICAgIHsKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CgogICAgICBpZiAoa2V5ID09IDI3IHx8IGtleSA9PSA4NCB8fCBrZXkgPT0gNjcpCiAgICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQoKICAgIGlmIChrZXkgPT0gMzQpIC8vIFBhZ2UgRG93bgogICAgewogICAgICBpZiAodzNjX3NsaWR5LnZpZXdfYWxsKQogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUoZmFsc2UpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzMpIC8vIFBhZ2UgVXAKICAgIHsKICAgICAgaWYgKHczY19zbGlkeS52aWV3X2FsbCkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIHczY19zbGlkeS5wcmV2aW91c19zbGlkZShmYWxzZSk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzMikgLy8gc3BhY2UgYmFyCiAgICB7CiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKHRydWUpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzcpIC8vIExlZnQgYXJyb3cKICAgIHsKICAgICAgdzNjX3NsaWR5LnByZXZpb3VzX3NsaWRlKCFldmVudC5zaGlmdEtleSk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzNikgLy8gSG9tZQogICAgewogICAgICB3M2Nfc2xpZHkuZmlyc3Rfc2xpZGUoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDM1KSAvLyBFbmQKICAgIHsKICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2xpZGUoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDM5KSAvLyBSaWdodCBhcnJvdwogICAgewogICAgICB3M2Nfc2xpZHkubmV4dF9zbGlkZSghZXZlbnQuc2hpZnRLZXkpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTMpIC8vIEVudGVyCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkub3V0bGluZSkKICAgICAgewogICAgICAgIGlmICh3M2Nfc2xpZHkub3V0bGluZS52aXNpYmxlKQogICAgICAgICAgdzNjX3NsaWR5LmZvbGQodzNjX3NsaWR5Lm91dGxpbmUpOwogICAgICAgIGVsc2UKICAgICAgICAgIHczY19zbGlkeS51bmZvbGQodzNjX3NsaWR5Lm91dGxpbmUpOwogICAgICAgICAgCiAgICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICAgIH0KICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAxODgpICAvLyA8IGZvciBzbWFsbGVyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5zbWFsbGVyKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAxOTApICAvLyA+IGZvciBsYXJnZXIgZm9udHMKICAgIHsKICAgICAgdzNjX3NsaWR5LmJpZ2dlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg5IHx8IGtleSA9PSAxMDkpICAvLyAtIGZvciBzbWFsbGVyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5zbWFsbGVyKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAxODcgfHwga2V5ID09IDE5MSB8fCBrZXkgPT0gMTA3KSAgLy8gPSArICBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDgzKSAgLy8gUyBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gNjYpICAvLyBCIGZvciBsYXJnZXIgZm9udHMKICAgIHsKICAgICAgdzNjX3NsaWR5LmJpZ2dlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gOTApICAvLyBaIGZvciBsYXN0IHNsaWRlCiAgICB7CiAgICAgIHczY19zbGlkeS5sYXN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3MCkgIC8vIEYgZm9yIHRvZ2dsZSB0b29sYmFyCiAgICB7CiAgICAgIHczY19zbGlkeS50b2dnbGVfdG9vbGJhcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gNjUpICAvLyBBIGZvciB0b2dnbGUgdmlldyBzaW5nbGUvYWxsIHNsaWRlcwogICAgewogICAgICB3M2Nfc2xpZHkudG9nZ2xlX3ZpZXcoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDc1KSAgLy8gdG9nZ2xlIGFjdGlvbiBvZiBsZWZ0IGNsaWNrIGZvciBuZXh0IHBhZ2UKICAgIHsKICAgICAgdzNjX3NsaWR5Lm1vdXNlX2NsaWNrX2VuYWJsZWQgPSAhdzNjX3NsaWR5Lm1vdXNlX2NsaWNrX2VuYWJsZWQ7CiAgICAgIHZhciBhbGVydF9tc2cgPSAodzNjX3NsaWR5Lm1vdXNlX2NsaWNrX2VuYWJsZWQgPwogICAgICAgICAgICAgICAgImVuYWJsZWQiIDogImRpc2FibGVkIikgKyAgIiBtb3VzZSBjbGljayBhZHZhbmNlIjsKCiAgICAgIGFsZXJ0KHczY19zbGlkeS5sb2NhbGl6ZShhbGVydF9tc2cpKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDg0IHx8IGtleSA9PSA2NykgIC8vIFQgb3IgQyBmb3IgdGFibGUgb2YgY29udGVudHMKICAgIHsKICAgICAgaWYgKHczY19zbGlkeS50b2MpCiAgICAgICAgdzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpOwoKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDcyKSAvLyBIIGZvciBoZWxwCiAgICB7CiAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHczY19zbGlkeS5oZWxwX3BhZ2U7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIC8vZWxzZSBhbGVydCgia2V5IGNvZGUgaXMgIisga2V5KTsKCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICAvLyBzYWZlIGZvciBib3RoIHRleHQvaHRtbCBhbmQgYXBwbGljYXRpb24veGh0bWwreG1sCiAgY3JlYXRlX2VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lKSB7CiAgICBpZiAodGhpcy54aHRtbCAmJiAodHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAhPSAndW5kZWZpbmVkJykpCiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiLCBuYW1lKQoKICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpOwogIH0sCgogIGdldF9lbGVtZW50X3N0eWxlOiBmdW5jdGlvbiAoZWxlbSwgSUVTdHlsZVByb3AsIENTU1N0eWxlUHJvcCkgewogICAgaWYgKGVsZW0uY3VycmVudFN0eWxlKQogICAgewogICAgICByZXR1cm4gZWxlbS5jdXJyZW50U3R5bGVbSUVTdHlsZVByb3BdOwogICAgfQogICAgZWxzZSBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpCiAgICB7CiAgICAgIHZhciBjb21wU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCAiIik7CiAgICAgIHJldHVybiBjb21wU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShDU1NTdHlsZVByb3ApOwogICAgfQogICAgcmV0dXJuICIiOwogIH0sCgogIC8vIHRoZSBzdHJpbmcgc3RyIGlzIGEgd2hpdGVzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0b2tlbnMKICAvLyB0ZXN0IGlmIHN0ciBjb250YWlucyBhIHBhcnRpY3VsYXIgdG9rZW4sIGUuZy4gInNsaWRlIgogIGhhc190b2tlbjogZnVuY3Rpb24gKHN0ciwgdG9rZW4pIHsKICAgIGlmIChzdHIpCiAgICB7CiAgICAgIC8vIGRlZmluZSBwYXR0ZXJuIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgICB2YXIgcGF0dGVybiA9IC9cdysvZzsKCiAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGVzCiAgICAgIC8vIHBsYWNlIHJlc3VsdCBpbiBhcnJheQogICAgICB2YXIgcmVzdWx0ID0gc3RyLm1hdGNoKHBhdHRlcm4pOwoKICAgICAgLy8gbm93IGNoZWNrIGlmIGRlc2lyZWQgdG9rZW4gaXMgcHJlc2VudAogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykKICAgICAgewogICAgICAgIGlmIChyZXN1bHRbaV0gPT0gdG9rZW4pCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9LAoKICBnZXRfY2xhc3NfbGlzdDogZnVuY3Rpb24gKGVsZW1lbnQpIHsKICAgIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgIT0gJ3VuZGVmaW5lZCcpCiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZTsKCiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImNsYXNzIik7CiAgfSwKCiAgaGFzX2NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgewogICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT0gMSkKICAgICAgcmV0dXJuIGZhbHNlOwoKICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCIoXnwgKSIgKyBuYW1lICsgIlxXKiIpOwoKICAgIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgIT0gJ3VuZGVmaW5lZCcpCiAgICAgIHJldHVybiByZWdleHAudGVzdChlbGVtZW50LmNsYXNzTmFtZSk7CgogICAgcmV0dXJuIHJlZ2V4cC50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpKTsKICB9LAoKICByZW1vdmVfY2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7CiAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgiKF58ICkiICsgbmFtZSArICJcVyoiKTsKICAgIHZhciBjbHN2YWwgPSAiIjsKCiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgewogICAgICBjbHN2YWwgPSBlbGVtZW50LmNsYXNzTmFtZTsKCiAgICAgIGlmIChjbHN2YWwpCiAgICAgIHsKICAgICAgICBjbHN2YWwgPSBjbHN2YWwucmVwbGFjZShyZWdleHAsICIiKTsKICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsc3ZhbDsKICAgICAgfQogICAgfQogICAgZWxzZQogICAgewogICAgICBjbHN2YWwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgiY2xhc3MiKTsKCiAgICAgIGlmIChjbHN2YWwpCiAgICAgIHsKICAgICAgICBjbHN2YWwgPSBjbHN2YWwucmVwbGFjZShyZWdleHAsICIiKTsKICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgiY2xhc3MiLCBjbHN2YWwpOwogICAgICB9CiAgICB9CiAgfSwKCiAgYWRkX2NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgewogICAgaWYgKCF0aGlzLmhhc19jbGFzcyhlbGVtZW50LCBuYW1lKSkKICAgIHsKICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSAhPSAndW5kZWZpbmVkJykKICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAiICIgKyBuYW1lOwogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB2YXIgY2xzdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImNsYXNzIik7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsID8gY2xzdmFsICsgIiAiICsgbmFtZSA6IG5hbWU7CiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgY2xzdmFsKTsKICAgICAgfQogICAgfQogIH0sCgogIC8vIEhUTUwgZWxlbWVudHMgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGNsYXNzPSJpbmNyZW1lbnRhbCIKICAvLyBub3RlIHRoYXQgeW91IGNhbiBhbHNvIHB1dCB0aGUgY2xhc3Mgb24gY29udGFpbmVycyBsaWtlCiAgLy8gdXAsIG9sLCBkbCwgYW5kIGRpdiB0byBtYWtlIHRoZWlyIGNvbnRlbnRzIGFwcGVhcgogIC8vIGluY3JlbWVudGFsbHkuIFVwcGVyIGNhc2UgaXMgdXNlZCBzaW5jZSB0aGlzIGlzIHdoYXQKICAvLyBicm93c2VycyByZXBvcnQgZm9yIEhUTUwgbm9kZSBuYW1lcyAodGV4dC9odG1sKS4KICBpbmNyZW1lbnRhbF9lbGVtZW50czogbnVsbCwKICBva2F5X2Zvcl9pbmNyZW1lbnRhbDogZnVuY3Rpb24gKG5hbWUpIHsKICAgIGlmICghdGhpcy5pbmNyZW1lbnRhbF9lbGVtZW50cykKICAgIHsKICAgICAgdmFyIGluY2xpc3QgPSBuZXcgQXJyYXkoKTsKICAgICAgaW5jbGlzdFsicCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsicHJlIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJsaSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiYmxvY2txdW90ZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiZHQiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImRkIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJoMiJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDMiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImg0Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJoNSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDYiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInNwYW4iXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImFkZHJlc3MiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInRhYmxlIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0ciJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsidGgiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInRkIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJpbWciXSA9IHRydWU7CiAgICAgIGluY2xpc3RbIm9iamVjdCJdID0gdHJ1ZTsKICAgICAgdGhpcy5pbmNyZW1lbnRhbF9lbGVtZW50cyA9IGluY2xpc3Q7CiAgICB9CiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRhbF9lbGVtZW50c1tuYW1lLnRvTG93ZXJDYXNlKCldOwogIH0sCgogIG5leHRfaW5jcmVtZW50YWxfaXRlbTogZnVuY3Rpb24gKG5vZGUpIHsKICAgIHZhciBiciA9IHRoaXMuaXNfeGh0bWwgPyAiYnIiIDogIkJSIjsKICAgIHZhciBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CgogICAgZm9yICg7OykKICAgIHsKICAgICAgbm9kZSA9IHczY19zbGlkeS5uZXh0X25vZGUoc2xpZGUsIG5vZGUpOwoKICAgICAgaWYgKG5vZGUgPT0gbnVsbCB8fCBub2RlLnBhcmVudE5vZGUgPT0gbnVsbCkKICAgICAgICBicmVhazsKCiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpICAvLyBFTEVNRU5UCiAgICAgIHsKICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBicikKICAgICAgICAgIGNvbnRpbnVlOwoKICAgICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLCAiaW5jcmVtZW50YWwiKQogICAgICAgICAgICAgJiYgdzNjX3NsaWR5Lm9rYXlfZm9yX2luY3JlbWVudGFsKG5vZGUubm9kZU5hbWUpKQogICAgICAgICAgcmV0dXJuIG5vZGU7CgogICAgICAgIGlmICh3M2Nfc2xpZHkuaGFzX2NsYXNzKG5vZGUucGFyZW50Tm9kZSwgImluY3JlbWVudGFsIikKICAgICAgICAgICAgICYmICF3M2Nfc2xpZHkuaGFzX2NsYXNzKG5vZGUsICJub24taW5jcmVtZW50YWwiKSkKICAgICAgICAgIHJldHVybiBub2RlOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgcHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbTogZnVuY3Rpb24gKG5vZGUpIHsKICAgIHZhciBiciA9IHRoaXMuaXNfeGh0bWwgPyAiYnIiIDogIkJSIjsKICAgIHZhciBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CgogICAgZm9yICg7OykKICAgIHsKICAgICAgbm9kZSA9IHczY19zbGlkeS5wcmV2aW91c19ub2RlKHNsaWRlLCBub2RlKTsKCiAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS5wYXJlbnROb2RlID09IG51bGwpCiAgICAgICAgYnJlYWs7CgogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKQogICAgICB7CiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gYnIpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgImluY3JlbWVudGFsIikKICAgICAgICAgICAgICYmIHczY19zbGlkeS5va2F5X2Zvcl9pbmNyZW1lbnRhbChub2RlLm5vZGVOYW1lKSkKICAgICAgICAgIHJldHVybiBub2RlOwoKICAgICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLnBhcmVudE5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiAhdzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLCAibm9uLWluY3JlbWVudGFsIikpCiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBub2RlOwogIH0sCgogIC8vIHNldCB2aXNpYmlsaXR5IGZvciBhbGwgZWxlbWVudHMgb24gY3VycmVudCBzbGlkZSB3aXRoCiAgLy8gYSBwYXJlbnQgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSBjbGFzcz0iaW5jcmVtZW50YWwiCiAgc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsOiBmdW5jdGlvbiAodmFsdWUpIHsKICAgIHZhciBub2RlID0gdGhpcy5uZXh0X2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CgogICAgaWYgKHZhbHVlID09ICJoaWRkZW4iKQogICAgewogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIHczY19zbGlkeS5hZGRfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwogICAgICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG5vZGUpOwogICAgICB9CiAgICB9CiAgICBlbHNlIC8vIHZhbHVlID09ICJ2aXNpYmxlIgogICAgewogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwogICAgICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG5vZGUpOwogICAgICB9CiAgICB9CiAgfSwKCiAgLy8gcmV2ZWFsIHRoZSBuZXh0IGhpZGRlbiBpdGVtIG9uIHRoZSBzbGlkZQogIC8vIG5vZGUgaXMgbnVsbCBvciB0aGUgbm9kZSB0aGF0IHdhcyBsYXN0IHJldmVhbGVkCiAgcmV2ZWFsX25leHRfaXRlbTogZnVuY3Rpb24gKG5vZGUpIHsKICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG5vZGUpOwoKICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSkgIC8vIGFuIGVsZW1lbnQKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyhub2RlLCAiaW52aXNpYmxlIik7CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgLy8gZXhhY3QgaW52ZXJzZSBvZiByZXZlYWxOZXh0SXRlbShub2RlKQogIGhpZGVfcHJldmlvdXNfaXRlbTogZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSkgIC8vIGFuIGVsZW1lbnQKICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyhub2RlLCAiaW52aXNpYmxlIik7CgogICAgcmV0dXJuIHRoaXMucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICB9LAoKICAvLyBsZWZ0IHRvIHJpZ2h0IHRyYXZlcnNhbCBvZiByb290J3MgY29udGVudAogIG5leHRfbm9kZTogZnVuY3Rpb24gKHJvb3QsIG5vZGUpIHsKICAgIGlmIChub2RlID09IG51bGwpCiAgICAgIHJldHVybiByb290LmZpcnN0Q2hpbGQ7CgogICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkKICAgICAgcmV0dXJuIG5vZGUuZmlyc3RDaGlsZDsKCiAgICBpZiAobm9kZS5uZXh0U2libGluZykKICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7CgogICAgZm9yICg7OykKICAgIHsKICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTsKCiAgICAgIGlmICghbm9kZSB8fCBub2RlID09IHJvb3QpCiAgICAgICAgYnJlYWs7CgogICAgICBpZiAobm9kZSAmJiBub2RlLm5leHRTaWJsaW5nKQogICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nOwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIC8vIHJpZ2h0IHRvIGxlZnQgdHJhdmVyc2FsIG9mIHJvb3QncyBjb250ZW50CiAgcHJldmlvdXNfbm9kZTogZnVuY3Rpb24gKHJvb3QsIG5vZGUpIHsKICAgIGlmIChub2RlID09IG51bGwpCiAgICB7CiAgICAgIG5vZGUgPSByb290Lmxhc3RDaGlsZDsKCiAgICAgIGlmIChub2RlKQogICAgICB7CiAgICAgICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKQogICAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkOwogICAgICB9CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KCiAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcpCiAgICB7CiAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZzsKCiAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkKICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KCiAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9IHJvb3QpCiAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7CgogICAgcmV0dXJuIG51bGw7CiAgfSwKCiAgcHJldmlvdXNfc2libGluZ19lbGVtZW50OiBmdW5jdGlvbiAoZWwpIHsKICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nOwoKICAgIHdoaWxlIChlbCAmJiBlbC5ub2RlVHlwZSAhPSAxKQogICAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZzsKCiAgICByZXR1cm4gZWw7CiAgfSwKCiAgbmV4dF9zaWJsaW5nX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbCkgewogICAgZWwgPSBlbC5uZXh0U2libGluZzsKCiAgICB3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgIT0gMSkKICAgICAgZWwgPSBlbC5uZXh0U2libGluZzsKCiAgICByZXR1cm4gZWw7CiAgfSwKCiAgZmlyc3RfY2hpbGRfZWxlbWVudDogZnVuY3Rpb24gKGVsKSB7CiAgICB2YXIgbm9kZTsKCiAgICBmb3IgKG5vZGUgPSBlbC5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZykKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkKICAgICAgICBicmVhazsKICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9LAoKICBmaXJzdF90YWc6IGZ1bmN0aW9uIChlbGVtZW50LCB0YWcpIHsKICAgIHZhciBub2RlOwoKICAgIGlmICghdGhpcy5pc194aHRtbCkKICAgICAgdGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7CgogICAgZm9yIChub2RlID0gZWxlbWVudC5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZykKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLm5vZGVOYW1lID09IHRhZykKICAgICAgICBicmVhazsKICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9LAoKICBoaWRlX3NlbGVjdGlvbjogZnVuY3Rpb24gKCkgewogICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIC8vIEZpcmVmb3gsIENocm9taXVtLCBTYWZhcmksIE9wZXJhCiAgICB7CiAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7CgogICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKQogICAgICB7CiAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7CiAgICAgICAgcmFuZ2UuY29sbGFwc2UgKGZhbHNlKTsKICAgICAgfQogICAgfQogICAgZWxzZSAvLyBJbnRlcm5ldCBFeHBsb3JlcgogICAgewogICAgICB2YXIgdGV4dFJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlICgpOwogICAgICB0ZXh0UmFuZ2UuY29sbGFwc2UgKGZhbHNlKTsKICAgIH0KICB9LAoKICBnZXRfc2VsZWN0ZWRfdGV4dDogZnVuY3Rpb24gKCkgewogICAgdHJ5CiAgICB7CiAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKQogICAgICAgIHJldHVybiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTsKCiAgICAgIGlmIChkb2N1bWVudC5nZXRTZWxlY3Rpb24pCiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7CgogICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKQogICAgICAgIHJldHVybiBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0OwogICAgfQogICAgY2F0Y2ggKGUpCiAgICB7CiAgICB9CgogICAgcmV0dXJuICIiOwogIH0sCgogIC8vIG1ha2Ugbm90ZSBvZiBsZW5ndGggb2Ygc2VsZWN0ZWQgdGV4dAogIC8vIGFzIHRoaXMgZXZhbHVhdGVzIHRvIHplcm8gaW4gY2xpY2sgZXZlbnQKICBtb3VzZV9idXR0b25fdXA6IGZ1bmN0aW9uIChlKSB7CiAgICB3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPSB3M2Nfc2xpZHkuZ2V0X3NlbGVjdGVkX3RleHQoKS5sZW5ndGg7CiAgfSwKCiAgbW91c2VfYnV0dG9uX2Rvd246IGZ1bmN0aW9uIChlKSB7CiAgICB3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPSB3M2Nfc2xpZHkuZ2V0X3NlbGVjdGVkX3RleHQoKS5sZW5ndGg7CiAgICB3M2Nfc2xpZHkubW91c2VfeCA9IGUuY2xpZW50WDsKICAgIHczY19zbGlkeS5tb3VzZV95ID0gZS5jbGllbnRZOwogIH0sCgogIC8vIHJpZ2h0IG1vdXNlIGJ1dHRvbiBjbGljayBpcyByZXNlcnZlZCBmb3IgY29udGV4dCBtZW51cwogIC8vIGl0IGlzIG1vcmUgcmVsaWFibGUgdG8gZGV0ZWN0IHJpZ2h0Y2xpY2sgdGhhbiBsZWZ0Y2xpY2sKICBtb3VzZV9idXR0b25fY2xpY2s6IGZ1bmN0aW9uIChlKSB7CiAgICBpZiAoIWUpCiAgICAgIHZhciBlID0gd2luZG93LmV2ZW50OwoKICAgIGlmIChNYXRoLmFicyhlLmNsaWVudFggLXczY19zbGlkeS5tb3VzZV94KSArCiAgICAgICAgTWF0aC5hYnMoZS5jbGllbnRZIC13M2Nfc2xpZHkubW91c2VfeSkgPiAxMCkKICAgICAgcmV0dXJuIHRydWU7CgogICAgaWYgKHczY19zbGlkeS5zZWxlY3RlZF90ZXh0X2xlbiA+IDApCiAgICAgIHJldHVybiB0cnVlOwoKICAgIHZhciByaWdodGNsaWNrID0gZmFsc2U7CiAgICB2YXIgbGVmdGNsaWNrID0gZmFsc2U7CiAgICB2YXIgbWlkZGxlY2xpY2sgPSBmYWxzZTsKICAgIHZhciB0YXJnZXQ7CgogICAgaWYgKCFlKQogICAgICB2YXIgZSA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoZS50YXJnZXQpCiAgICAgIHRhcmdldCA9IGUudGFyZ2V0OwogICAgZWxzZSBpZiAoZS5zcmNFbGVtZW50KQogICAgICB0YXJnZXQgPSBlLnNyY0VsZW1lbnQ7CgogICAgLy8gd29yayBhcm91bmQgU2FmYXJpIGJ1ZwogICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAzKQogICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTsKCiAgICBpZiAoZS53aGljaCkgLy8gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRQogICAgewogICAgICBsZWZ0Y2xpY2sgPSAoZS53aGljaCA9PSAxKTsKICAgICAgbWlkZGxlY2xpY2sgPSAoZS53aGljaCA9PSAyKTsKICAgICAgcmlnaHRjbGljayA9IChlLndoaWNoID09IDMpOwogICAgfQogICAgZWxzZSBpZiAoZS5idXR0b24pCiAgICB7CiAgICAgIC8vIEtvbnF1ZXJvciBnaXZlcyAxIGZvciBsZWZ0LCA0IGZvciBtaWRkbGUKICAgICAgLy8gSUU2IGdpdmVzIDAgZm9yIGxlZnQgYW5kIG5vdCAxIGFzIEkgZXhwZWN0ZWQKCiAgICAgIGlmIChlLmJ1dHRvbiA9PSA0KQogICAgICAgIG1pZGRsZWNsaWNrID0gdHJ1ZTsKCiAgICAgIC8vIGFsbCBicm93c2VycyBhZ3JlZSBvbiAyIGZvciByaWdodCBidXR0b24KICAgICAgcmlnaHRjbGljayA9IChlLmJ1dHRvbiA9PSAyKTsKICAgIH0KICAgIGVsc2UKICAgICAgbGVmdGNsaWNrID0gdHJ1ZTsKCiAgICBpZiAodzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID4gMCkKICAgIHsKICAgICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICAgIGUuY2FuY2VsID0gdHJ1ZTsKICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOwogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgLy8gZGlzbWlzcyB0YWJsZSBvZiBjb250ZW50cwogICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHMoZmFsc2UpOwoKICAgIC8vIGNoZWNrIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdGhhdCBwcm9iYWJseSB3YW50J3MgY2xpY2tzCiAgICAvLyBlLmcuIGEsIGVtYmVkLCBvYmplY3QsIGlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBvcHRpb24KICAgIHZhciB0YWcgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICBpZiAodzNjX3NsaWR5Lm1vdXNlX2NsaWNrX2VuYWJsZWQgJiYgbGVmdGNsaWNrICYmCiAgICAgICAgIXczY19zbGlkeS5zcGVjaWFsX2VsZW1lbnQodGFyZ2V0KSAmJgogICAgICAgICF0YXJnZXQub25jbGljaykKICAgIHsKICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUodHJ1ZSk7CiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIHJldHVybiB0cnVlOwogIH0sCgogIHNwZWNpYWxfZWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHsKICAgIGlmICh0aGlzLmhhc19jbGFzcyhlbGVtZW50LCAibm9uLWludGVyYWN0aXZlIikpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgdGFnID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOwoKICAgIHJldHVybiBlbGVtZW50Lm9ua2V5ZG93biB8fAogICAgICBlbGVtZW50Lm9uY2xpY2sgfHwKICAgICAgdGFnID09ICJhIiB8fAogICAgICB0YWcgPT0gImVtYmVkIiB8fAogICAgICB0YWcgPT0gIm9iamVjdCIgfHwKICAgICAgdGFnID09ICJ2aWRlbyIgfHwKICAgICAgdGFnID09ICJhdWRpbyIgfHwKICAgICAgdGFnID09ICJzdmciIHx8CiAgICAgIHRhZyA9PSAiY2FudmFzIiB8fAogICAgICB0YWcgPT0gImlucHV0IiB8fAogICAgICB0YWcgPT0gInRleHRhcmVhIiB8fAogICAgICB0YWcgPT0gInNlbGVjdCIgfHwKICAgICAgdGFnID09ICJvcHRpb24iOwogIH0sCgogIHNsaWR5X2Nocm9tZTogZnVuY3Rpb24gKGVsKSB7CiAgICB3aGlsZSAoZWwpCiAgICB7CiAgICAgIGlmIChlbCA9PSB3M2Nfc2xpZHkudG9jIHx8CiAgICAgICAgICBlbCA9PSB3M2Nfc2xpZHkudG9vbGJhciB8fAogICAgICAgICAgdzNjX3NsaWR5Lmhhc19jbGFzcyhlbCwgIm91dGxpbmUiKSkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIGVsID0gZWwucGFyZW50Tm9kZTsKICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgZ2V0X2tleTogZnVuY3Rpb24gKGUpCiAgewogICAgdmFyIGtleTsKCiAgICAvLyBrbHVkZ2UgYXJvdW5kIE5TL0lFIGRpZmZlcmVuY2VzIAogICAgaWYgKHR5cGVvZiB3aW5kb3cuZXZlbnQgIT0gInVuZGVmaW5lZCIpCiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgZWxzZSBpZiAoZS53aGljaCkKICAgICAga2V5ID0gZS53aGljaDsKCiAgICByZXR1cm4ga2V5OwogIH0sCgogIGdldF90YXJnZXQ6IGZ1bmN0aW9uIChlKSB7CiAgICB2YXIgdGFyZ2V0OwoKICAgIGlmICghZSkKICAgICAgZSA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoZS50YXJnZXQpCiAgICAgIHRhcmdldCA9IGUudGFyZ2V0OwogICAgZWxzZSBpZiAoZS5zcmNFbGVtZW50KQogICAgICB0YXJnZXQgPSBlLnNyY0VsZW1lbnQ7CgogICAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPSAxKQogICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTsKCiAgICByZXR1cm4gdGFyZ2V0OwogIH0sCgogIC8vIGRvZXMgZGlzcGxheSBwcm9wZXJ0eSBwcm92aWRlIGNvcnJlY3QgZGVmYXVsdHM/CiAgaXNfYmxvY2s6IGZ1bmN0aW9uIChlbGVtKSB7CiAgICB2YXIgdGFnID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOwoKICAgIHJldHVybiB0YWcgPT0gIm9sIiB8fCB0YWcgPT0gInVsIiB8fCB0YWcgPT0gInAiIHx8IHRhZyA9PSAiZGwiIHx8CiAgICAgICAgICAgdGFnID09ICJsaSIgfHwgdGFnID09ICJ0YWJsZSIgfHwgdGFnID09ICJwcmUiIHx8CiAgICAgICAgICAgdGFnID09ICJoMSIgfHwgdGFnID09ICJoMiIgfHwgdGFnID09ICJoMyIgfHwKICAgICAgICAgICB0YWcgPT0gImg0IiB8fCB0YWcgPT0gImg1IiB8fCB0YWcgPT0gImg2IiB8fAogICAgICAgICAgIHRhZyA9PSAiYmxvY2txdW90ZSIgfHwgdGFnID09ICJhZGRyZXNzIjsgCiAgfSwKCiAgYWRkX2xpc3RlbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHsKICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikKICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7CiAgICBlbHNlCiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoIm9uIitldmVudCwgaGFuZGxlcik7CiAgfSwKCiAgLy8gdXNlZCB0byBwcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uIGZyb20gZmllbGQgY29udHJvbHMKICBzdG9wX3Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGV2ZW50ID0gZXZlbnQgPyBldmVudCA6IHdpbmRvdy5ldmVudDsKICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7ICAvLyBmb3IgSUUKCiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKQogICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsKCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICBjYW5jZWw6IGZ1bmN0aW9uIChldmVudCkgewogICAgaWYgKGV2ZW50KQogICAgewogICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTsKICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7CgogICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpCiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsKICAgIH0KCiAgICB3M2Nfc2xpZHkua2V5X3dhbnRlZCA9IGZhbHNlOwogICAgcmV0dXJuIGZhbHNlOwogIH0sCgovLyBmb3IgZWFjaCBsYW5ndWFnZSBkZWZpbmUgYW4gYXNzb2NpYXRpdmUgYXJyYXkKLy8gYW5kIGFsc28gdGhlIGhlbHAgdGV4dCB3aGljaCBpcyBsb25nZXIKCiAgc3RyaW5nc19lczogewogICAgInNsaWRlIjoicMOhZy4iLAogICAgImhlbHA/IjoiQXl1ZGEiLAogICAgImNvbnRlbnRzPyI6IsONbmRpY2UiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoidGFibGEgZGUgY29udGVuaWRvcyIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJUYWJsYSBkZSBDb250ZW5pZG9zIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IlJlaW5pY2lhciBwcmVzZW50YWNpw7NuIiwKICAgICJyZXN0YXJ0PyI6IkluaWNpbyIKICB9LAogIGhlbHBfZXM6CiAgICAiVXRpbGljZSBlbCByYXTDs24sIGJhcnJhIGVzcGFjaWFkb3JhLCB0ZWNsYXMgSXpkYS9EY2hhLCAiICsKICAgICJvIFJlIHDDoWcgeSBBdiBww6FnLiBVc2UgUyB5IEIgcGFyYSBjYW1iaWFyIGVsIHRhbWHDsW8gZGUgZnVlbnRlLiIsCgogIHN0cmluZ3NfY2E6IHsKICAgICJzbGlkZSI6InDDoGcuLiIsCiAgICAiaGVscD8iOiJBanVkYSIsCiAgICAiY29udGVudHM/Ijoiw41uZGV4IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6InRhdWxhIGRlIGNvbnRpbmd1dHMiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiVGF1bGEgZGUgQ29udGluZ3V0cyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZWluaWNpYXIgcHJlc2VudGFjacOzIiwKICAgICJyZXN0YXJ0PyI6IkluaWNpIgogIH0sCiAgaGVscF9jYToKICAgICJVdGlsaXR6aSBlbCByYXRvbMOtLCBiYXJyYSBlc3BhaWFkb3JhLCB0ZWNsZXMgRXNxLi9EdGEuICIgKwogICAgIm8gUmUgcMOgZyB5IEF2IHDDoGcuIFVzaSBTIGkgQiBwZXIgY2FudmlhciBncmFuZMOgcmlhIGRlIGZvbnQuIiwKCiAgc3RyaW5nc19jczogewogICAgInNsaWRlIjoic27DrW1layIsCiAgICAiaGVscD8iOiJuw6Fwb3bEm2RhIiwKICAgICJjb250ZW50cz8iOiJvYnNhaCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJvYnNhaCBwcmV6ZW50YWNlIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6Ik9ic2FoIHByZXplbnRhY2UiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiem5vdnUgc3B1c3RpdCBwcmV6ZW50YWNpIiwKICAgICJyZXN0YXJ0PyI6InJlc3RhcnQiCiAgfSwKICBoZWxwX2NzOgogICAgIlByZXplbnRhY2kgbcWvxb5ldGUgcHJvY2jDoXpldCBwb21vY8OtIGtsaWtudXTDrSBtecWhaSwgbWV6ZXJuw61rdSwgIiArCiAgICAixaFpcGVrIHZsZXZvIGEgdnByYXZvIG5lYm8ga2zDoXZlcyBQYWdlVXAgYSBQYWdlRG93bi4gUMOtc21vIHNlICIgKwogICAgImTDoSB6dsSbdMWhaXQgYSB6bWVuxaFpdCBwb21vY8OtIGtsw6F2ZXMgQiBhIFMuIiwKCiAgc3RyaW5nc19ubDogewogICAgInNsaWRlIjoicGFnaW5hIiwKICAgICJoZWxwPyI6IkhlbHA/IiwKICAgICJjb250ZW50cz8iOiJJbmhvdWQ/IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6ImluaG91ZHNvcGdhdmUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiSW5ob3Vkc29wZ2F2ZSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJoZXJzdGFydCBwcmVzZW50YXRpZSIsCiAgICAicmVzdGFydD8iOiJIZXJzdGFydD8iCiAgfSwKICBoZWxwX25sOgogICAgICJOYXZpZ2VlciBkLm0udi4gaGV0IG11aXMsIHNwYXRpZWJhciwgTGlua3MvUmVjaHRzIHRvZXRzZW4sICIgKwogICAgICJvZiBQZ1VwIGVuIFBnRG4uIEdlYnJ1aWsgUyBlbiBCIG9tIGRlIGthcmFrdGVyZ3Jvb3R0ZSB0ZSB2ZXJhbmRlcmVuLiIsCgogIHN0cmluZ3NfZGU6IHsKICAgICJzbGlkZSI6IlNlaXRlIiwKICAgICJoZWxwPyI6IkhpbGZlIiwKICAgICJjb250ZW50cz8iOiLDnGJlcnNpY2h0IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6IkluaGFsdHN2ZXJ6ZWljaG5pcyIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJJbmhhbHRzdmVyemVpY2huaXMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUHLDpHNlbnRhdGlvbiBuZXUgc3RhcnRlbiIsCiAgICAicmVzdGFydD8iOiJOZXVzdGFydCIKICB9LAogIGhlbHBfZGU6CiAgICAiQmVudXR6ZW4gU2llIGRpZSBNYXVzLCBMZWVyc2NobGFnLCBkaWUgQ3Vyc29ydGFzdGVuIGxpbmtzL3JlY2h0cyBvZGVyICIgKwogICAgIlBhZ2UgdXAvUGFnZSBEb3duIHp1bSBXZWNoc2VsbiBkZXIgU2VpdGVuIHVuZCBTIHVuZCBCIGbDvHIgZGllIFNjaHJpZnRncsO2c3NlLiIsCgogIHN0cmluZ3NfcGw6IHsKICAgICJzbGlkZSI6InNsYWpkIiwKICAgICJoZWxwPyI6InBvbW9jPyIsCiAgICAiY29udGVudHM/Ijoic3BpcyB0cmXFm2NpPyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJzcGlzIHRyZcWbY2kiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiU3BpcyBUcmXFm2NpIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IlJlc3RhcnR1aiBwcmV6ZW50YWNqxJkiLAogICAgInJlc3RhcnQ/IjoicmVzdGFydD8iCiAgfSwKICBoZWxwX3BsOgogICAgIlptaWVuaWFqIHNsYWpkeSBrbGlrYWrEhWMgbXlzesSFLCBuYWNpc2thasSFYyBzcGFjasSZLCBzdHJ6YcWCa2kgbGV3by9wcmF3byIgKwogICAgImx1YiBQZ1VwIC8gUGdEbi4gVcW8eWoga2xhd2lzenkgUyBpIEIsIGFieSB6bWllbmnEhyByb3ptaWFyIGN6Y3ppb25raS4iLAoKICBzdHJpbmdzX2ZyOiB7CiAgICAic2xpZGUiOiJwYWdlIiwKICAgICJoZWxwPyI6IkFpZGUiLAogICAgImNvbnRlbnRzPyI6IkluZGV4IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6InRhYmxlIGRlcyBtYXRpw6hyZXMiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiVGFibGUgZGVzIG1hdGnDqHJlcyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZWNvbW1lbmNlciBsJ2V4cG9zw6kiLAogICAgInJlc3RhcnQ/IjoiRMOpYnV0IgogIH0sCiAgaGVscF9mcjoKICAgICJOYXZpZ3VleiBhdmVjIGxhIHNvdXJpcywgbGEgYmFycmUgZCdlc3BhY2UsIGxlcyBmbMOoY2hlcyAiICsKICAgICJnYXVjaGUvZHJvaXRlIG91IGxlcyB0b3VjaGVzIFBnIFVwLCBQZyBEbi4gVXRpbGlzZXogIiArCiAgICAibGVzIHRvdWNoZXMgUyBldCBCIHBvdXIgbW9kaWZpZXIgbGEgdGFpbGxlIGRlIGxhIHBvbGljZS4iLAoKICBzdHJpbmdzX2h1OiB7CiAgICAic2xpZGUiOiJvbGRhbCIsCiAgICAiaGVscD8iOiJzZWfDrXRzw6lnIiwKICAgICJjb250ZW50cz8iOiJ0YXJ0YWxvbSIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YXJ0YWxvbWplZ3l6w6lrIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhcnRhbG9tamVneXrDqWsiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiYmVtdXRhdMOzIMO6anJhaW5kw610w6FzYSIsCiAgICAicmVzdGFydD8iOiLDumpyYWluZMOtdMOhcyIKICB9LAogIGhlbHBfaHU6CiAgICAiQXogb2xkYWxhayBrw7Z6dGkgbMOpcGtlZMOpc2hleiBrYXR0aW50c29uIGF6IGVnw6lycmVsLCB2YWd5ICIgKwogICAgImhhc3puw6FsamEgYSBzesOza8O2eiwgYSBiYWwsIHZhZ3kgYSBqb2JiIG55w61sLCBpbGxldHZlIGEgUGFnZSBEb3duLCAiICsKICAgICJQYWdlIFVwIGJpbGxlbnR5xbFrZXQuIEF6IFMgw6lzIGEgQiBiaWxsZW50ecWxa2tlbCB2w6FsdG96dGF0aGF0amEgIiArCiAgICAiYSBzesO2dmVnIG3DqXJldMOpdC4iLAoKICBzdHJpbmdzX2l0OiB7CiAgICAic2xpZGUiOiJwYWcuIiwKICAgICJoZWxwPyI6IkFpdXRvIiwKICAgICJjb250ZW50cz8iOiJJbmRpY2UiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoiaW5kaWNlIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IkluZGljZSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSaWNvbWluY2lhcmUgbGEgcHJlc2VudGF6aW9uZSIsCiAgICAicmVzdGFydD8iOiJJbml6aW8iCiAgfSwKICBoZWxwX2l0OgogICAgIk5hdmlnYXJlIGNvbiBtb3VzZSwgYmFycmEgc3BhemlvLCBmcmVjY2Ugc2luaXN0cmEvZGVzdHJhIG8gIiArCiAgICAiUGdVcCBlIFBnRG4uIFVzYXJlIFMgZSBCIHBlciBjYW1iaWFyZSBsYSBkaW1lbnNpb25lIGRlaSBjYXJhdHRlcmkuIiwKCiAgc3RyaW5nc19lbDogewogICAgInNsaWRlIjoiz4POtc67zq/OtM6xIiwKICAgICJoZWxwPyI6Is6yzr/Ors64zrXOuc6xOyIsCiAgICAiY29udGVudHM/Ijoiz4DOtc+BzrnOtc+Hz4zOvM61zr3OsTsiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoiz4DOr869zrHOus6xz4Igz4DOtc+BzrnOtc+Hzr/OvM6tzr3Pic69IiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6Is6gzq/Ovc6xzrrOsc+CIM6gzrXPgc65zrXPh86/zrzOrc69z4nOvSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiLOtc+AzrHOvc61zrrOus6vzr3Ot8+Dzrcgz4DOsc+Bzr/Phc+Dzq/Osc+DzrfPgiIsCiAgICAicmVzdGFydD8iOiLOtc+AzrHOvc61zrrOus6vzr3Ot8+Dzrc7IgogIH0sCiAgaGVscF9lbDoKICAgICLOoM67zr/Ot86zzrfOuM61zq/PhM61IM68zrUgz4TOvyDOus67zq/OuiDPhM6/z4Ugz4DOv869z4TOuc66zrnOv8+NLCDPhM6/IHNwYWNlLCDPhM6xIM6yzq3Ou863IM6xz4HOuc+Dz4TOtc+BzqwvzrTOtc6+zrnOrCwgIiArCiAgICAizq4gUGFnZSBVcCDOus6xzrkgUGFnZSBEb3duLiDOp8+BzrfPg865zrzOv8+Azr/Ouc6uz4PPhM61IM+EzrEgz4DOu86uzrrPhM+BzrEgUyDOus6xzrkgQiDOs865zrEgzr3OsSDOsc67zrvOrM6+zrXPhM61ICIgKwogICAgIs+Ezr8gzrzOrc6zzrXOuM6/z4Igz4TOt8+CIM6zz4HOsc68zrzOsc+Ezr/Pg861zrnPgc6sz4IuIiwKCiAgc3RyaW5nc19qYTogewogICAgInNsaWRlIjoi44K544Op44Kk44OJIiwKICAgICJoZWxwPyI6IuODmOODq+ODlyIsCiAgICAiY29udGVudHM/Ijoi55uu5qyhIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6IuebruasoeOCkuihqOekuiIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLnm67mrKEiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoi5pyA5Yid44GL44KJ5YaN55SfIiwKICAgICJyZXN0YXJ0PyI6IuacgOWIneOBi+OCiSIKICB9LAogIGhlbHBfamE6CiAgICAgIuODnuOCpuOCueW3puOCr+ODquODg+OCryDjg7sg44K544Oa44O844K5IOODuyDlt6blj7Pjgq3jg7wgIiArCiAgICAgIuOBvuOBn+OBryBQYWdlIFVwIOODuyBQYWdlIERvd27jgafmk43kvZzvvIwgUyDjg7sgQuOBp+ODleOCqeODs+ODiOOCteOCpOOCuuWkieabtCIsCgogIHN0cmluZ3Nfemg6IHsKICAgICJzbGlkZSI6IuW5u+eBr+eJhyIsCiAgICAiaGVscD8iOiLluK7liqk/IiwKICAgICJjb250ZW50cz8iOiLlhoXlrrk/IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6IuebruW9lSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLnm67lvZUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoi6YeN5paw5ZCv5Yqo5bGV56S6IiwKICAgICJyZXN0YXJ0PyI6IumHjeaWsOWQr+WKqD8iCiAgfSwKICBoZWxwX3poOgogICAgIueUqOm8oOagh+eCueWHuywg56m65qC85p2hLCDlt6blj7Pnrq3lpLQsIFBnIFVwIOWSjCBQZyBEbiDlr7zoiKouICIgKwogICAgIueUqCBTLCBCIOaUueWPmOWtl+S9k+Wkp+Wwjy4iLAoKICBzdHJpbmdzX3J1OiB7CiAgICAic2xpZGUiOiLRgdC70LDQudC0IiwKICAgICJoZWxwPyI6ItC/0L7QvNC+0YnRjD8iLAogICAgImNvbnRlbnRzPyI6ItGB0L7QtNC10YDQttCw0L3QuNC1PyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLQvtCz0LvQsNCy0LvQtdC90LjQtSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLQntCz0LvQsNCy0LvQtdC90LjQtSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiLQv9C10YDQtdC30LDQv9GD0YHRgtC40YLRjCDQv9GA0LXQt9C10L3RgtCw0YbQuNGOIiwKICAgICJyZXN0YXJ0PyI6ItC/0LXRgNC10LfQsNC/0YPRgdC6PyIKICB9LAogIGhlbHBfcnU6CiAgICAi0J/QtdGA0LXQvNC10YnQsNC50YLQtdGB0Ywg0LrQu9C40LrQsNGPINC80YvRiNC60L7QuSwg0LjRgdC/0L7Qu9GM0LfRg9GPINC60LvQsNCy0LjRiNGDINC/0YDQvtCx0LXQuywg0YHRgtGA0LXQu9C60LgiICsKICAgICLQstC70LXQstC+L9Cy0L/RgNCw0LLQviDQuNC70LggUGcgVXAg0LggUGcgRG4uINCa0LvQsNCy0LjRiNC4IFMg0LggQiDQvNC10L3Rj9GO0YIg0YDQsNC30LzQtdGAINGI0YDQuNGE0YLQsC4iLAoKICBzdHJpbmdzX3N2OiB7CiAgICAic2xpZGUiOiJzaWRhIiwKICAgICJoZWxwPyI6Imhqw6RscCIsCiAgICAiY29udGVudHM/IjoiaW5uZWjDpWxsIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6ImlubmVow6VsbHNmw7ZydGVja25pbmciLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiSW5uZWjDpWxsc2bDtnJ0ZWNrbmluZyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJ2aXNhIHByZXNlbnRhdGlvbmVuIGZyw6VuIGLDtnJqYW4iLAogICAgInJlc3RhcnQ/IjoiYsO2cmphIG9tIgogIH0sCiAgaGVscF9zdjoKICAgICJCbMOkZGRyYSBtZWQgZXR0IGtsaWNrIG1lZCB2w6Ruc3RyYSBtdXNrbmFwcGVuLCBtZWxsYW5zbGFnc3RhbmdlbnRlbiwgIiArCiAgICAidsOkbnN0ZXItIG9jaCBow7ZnZXJwaWx0YW5nZW50ZXJuYSBlbGxlciB0YW5nZW50ZXJuYSBQZyBVcCwgUGcgRG4uICIgKwogICAgIkFudsOkbmQgdGFuZ2VudGVybmEgUyBvY2ggQiBmw7ZyIGF0dCDDpG5kcmEgdGV4dGVucyBzdG9ybGVrLiIsCgogIHN0cmluZ3M6IHsgfSwKCiAgbG9jYWxpemU6IGZ1bmN0aW9uIChzcmMpIHsKICAgIGlmIChzcmMgPT0gIiIpCiAgICAgIHJldHVybiBzcmM7CgogICAgIC8vIHRyeSBmdWxsIGxhbmd1YWdlIGNvZGUsIGUuZy4gZW4tVVMKICAgICB2YXIgcywgbG9va3VwID0gdzNjX3NsaWR5LnN0cmluZ3NbdzNjX3NsaWR5LmxhbmddOwoKICAgICBpZiAobG9va3VwKQogICAgIHsKICAgICAgIHMgPSBsb29rdXBbc3JjXTsKCiAgICAgICBpZiAocykKICAgICAgICByZXR1cm4gczsKICAgICB9CgogICAgIC8vIHN0cmlwIGNvdW50cnkgY29kZSBzdWZmaXgsIGUuZy4KICAgICAvLyB0cnkgZW4gaWYgdW5kZWZpbmVkIGZvciBlbi1VUwogICAgIHZhciBsZyA9IHczY19zbGlkeS5sYW5nLnNwbGl0KCItIik7CgogICAgIGlmIChsZy5sZW5ndGggPiAxKQogICAgIHsKICAgICAgIGxvb2t1cCA9IHczY19zbGlkeS5zdHJpbmdzW2xnWzBdXTsKCiAgICAgICBpZiAobG9va3VwKQogICAgICAgewogICAgICAgICBzID0gbG9va3VwW3NyY107CgogICAgICAgICBpZiAocykKICAgICAgICAgIHJldHVybiBzOwogICAgICAgfQogICAgIH0KCiAgICAgLy8gb3RoZXJ3aXNlIHN0cmluZyBhcyBpcwogICAgIHJldHVybiBzcmM7CiAgfSwKCiAgaW5pdF9sb2NhbGl6YXRpb246IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpMThuID0gdzNjX3NsaWR5OwogICAgdmFyIGhlbHBfdGV4dCA9IHczY19zbGlkeS5oZWxwX3RleHQ7CgogICAgLy8gZWFjaCBzdWNoIGxhbmd1YWdlIGFycmF5IGlzIGRlY2xhcmVkIGluIHRoZSBsb2NhbGl6ZSBhcnJheQogICAgLy8gdGhpcyBpcyB1c2VkIGFzIGluICB3M2Nfc2xpZHkubG9jYWxpemUoImZvbyIpOwogICAgdGhpcy5zdHJpbmdzID0gewogICAgICAiZXMiOnRoaXMuc3RyaW5nc19lcywKICAgICAgImNhIjp0aGlzLnN0cmluZ3NfY2EsCiAgICAgICJjcyI6dGhpcy5zdHJpbmdzX2NzLAogICAgICAibmwiOnRoaXMuc3RyaW5nc19ubCwKICAgICAgImRlIjp0aGlzLnN0cmluZ3NfZGUsCiAgICAgICJwbCI6dGhpcy5zdHJpbmdzX3BsLAogICAgICAiZnIiOnRoaXMuc3RyaW5nc19mciwKICAgICAgImh1Ijp0aGlzLnN0cmluZ3NfaHUsCiAgICAgICJpdCI6dGhpcy5zdHJpbmdzX2l0LAogICAgICAiZWwiOnRoaXMuc3RyaW5nc19lbCwKICAgICAgImpwIjp0aGlzLnN0cmluZ3NfamEsCiAgICAgICJ6aCI6dGhpcy5zdHJpbmdzX3poLAogICAgICAicnUiOnRoaXMuc3RyaW5nc19ydSwKICAgICAgInN2Ijp0aGlzLnN0cmluZ3Nfc3YKICAgIH0sCgogICAgaTE4bi5zdHJpbmdzX2VzW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZXM7CiAgICBpMThuLnN0cmluZ3NfY2FbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9jYTsKICAgIGkxOG4uc3RyaW5nc19jc1toZWxwX3RleHRdID0gaTE4bi5oZWxwX2NzOwogICAgaTE4bi5zdHJpbmdzX25sW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfbmw7CiAgICBpMThuLnN0cmluZ3NfZGVbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9kZTsKICAgIGkxOG4uc3RyaW5nc19wbFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX3BsOwogICAgaTE4bi5zdHJpbmdzX2ZyW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZnI7CiAgICBpMThuLnN0cmluZ3NfaHVbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9odTsKICAgIGkxOG4uc3RyaW5nc19pdFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX2l0OwogICAgaTE4bi5zdHJpbmdzX2VsW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZWw7CiAgICBpMThuLnN0cmluZ3NfamFbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9qYTsKICAgIGkxOG4uc3RyaW5nc196aFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX3poOwogICAgaTE4bi5zdHJpbmdzX3J1W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfcnU7CiAgICBpMThuLnN0cmluZ3Nfc3ZbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9zdjsKCiAgICB3M2Nfc2xpZHkubGFuZyA9IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoImxhbmciKTsKCiAgICBpZiAoIXczY19zbGlkeS5sYW5nKQogICAgICB3M2Nfc2xpZHkubGFuZyA9IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoInhtbDpsYW5nIik7CgogICAgaWYgKCF3M2Nfc2xpZHkubGFuZykKICAgICAgdzNjX3NsaWR5LmxhbmcgPSAiZW4iOwogIH0KfTsKCi8vIGhhY2sgZm9yIGJhY2sgYnV0dG9uIGJlaGF2aW9yCmlmICh3M2Nfc2xpZHkuaWU2IHx8IHczY19zbGlkeS5pZTcpCnsKICBkb2N1bWVudC53cml0ZSgiPGlmcmFtZSBpZD0naGlzdG9yeUZyYW1lJyAiICsKICAic3JjPSdqYXZhc2NyaXB0OlwiPGh0bWwiKyI+PC8iKyJodG1sPlwiJyAiICsKICAiaGVpZ2h0PScxJyB3aWR0aD0nMScgIiArCiAgInN0eWxlPSdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi04MDBweCc+PC9pZnJhbWU+Iik7Cn0KCi8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgZm9yIGluaXRpYWxpemF0aW9uCnczY19zbGlkeS5zZXRfdXAoKTsKCi8vIGhpZGUgdGhlIHNsaWRlcyBhcyBzb29uIGFzIGJvZHkgZWxlbWVudCBpcyBhdmFpbGFibGUKLy8gdG8gcmVkdWNlIGFubm95aW5nIHNjcmVlbiBtZXNzIGJlZm9yZSB0aGUgb25sb2FkIGV2ZW50CnNldFRpbWVvdXQodzNjX3NsaWR5LmhpZGVfc2xpZGVzLCA1MCk7Cgo=" charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Initial and Final Encodings</h1>
  <p class="author">

  </p>
</div>
<div id="introduction" class="slide section level1">
<h1>Introduction</h1>
<p>Code is Data, and Data is Code</p>
<p>Changing how you represent your data or your program can yield practical improvements.</p>
</div>
<div id="the-basic-idea" class="slide section level1">
<h1>The Basic Idea</h1>
<p>Consider the humble linked list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span>
            <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<ul>
<li>Start at the head</li>
<li>Do something on each element in order</li>
</ul>
</div>
<div id="the-basic-idea-1" class="slide section level1">
<h1>The Basic Idea</h1>
<p>What if we turned the list inside-out?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> <span class="fu">=</span> <span class="dt">DList</span> {<span class="ot"> runDList ::</span> [a] <span class="ot">-&gt;</span> [a] }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromDList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a
fromDList lst <span class="fu">=</span> <span class="dt">DList</span> (<span class="fu">++</span> lst)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toDList ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]
toDList (<span class="dt">DList</span> f) <span class="fu">=</span> f []</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a
cons x (<span class="dt">DList</span> xs) <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">$</span> (x <span class="fu">:</span>) <span class="fu">.</span> xs

<span class="co">-- cons x (DList xs) = DList $ \g -&gt; x : (xs g)</span></code></pre></div>
</div>
<div id="the-basic-idea-2" class="slide section level1">
<h1>The Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
[]     <span class="fu">++</span> bs <span class="fu">=</span> bs
(a<span class="fu">:</span>as) <span class="fu">++</span> bs <span class="fu">=</span> a <span class="fu">:</span> (as <span class="fu">++</span> bs)

<span class="co">-- call `:` once per element of the first list, every time you call `++`!</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">appendDList ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a
appendDList (<span class="dt">DList</span> xs) (<span class="dt">DList</span> ys) <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">$</span> xs <span class="fu">.</span> ys

<span class="co">-- appendDList (DList xs) (DList ys) = DList $ \g -&gt; xs (ys g)</span>

<span class="co">-- call (.) once per call to `appendDList`!</span></code></pre></div>
</div>
<div id="a-less-basic-idea" class="slide section level1">
<h1>A Less Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>  <span class="co">-- so we can use 'forall'</span>

<span class="kw">newtype</span> <span class="dt">Church</span> a <span class="fu">=</span> <span class="dt">Church</span> {
<span class="ot">  runChurch ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r)    <span class="ot">-&gt;</span> r   <span class="ot">-&gt;</span> r
               <span class="co">--          cons           nil    result</span>
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">convert ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Church</span> a
convert lst <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> foldr c n lst</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span>
<span class="ot">c ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r  <span class="co">-- the folding function</span>
<span class="ot">n ::</span> r            <span class="co">-- the terminating value</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">excommunicate ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> [a]
excommunicate ch <span class="fu">=</span> runChurch ch (<span class="fu">:</span>) []</code></pre></div>
</div>
<div id="the-basic-idea-3" class="slide section level1">
<h1>The Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">appendChurch ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a
appendChurch xs ys <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> runChurch xs c <span class="fu">$</span> runChurch ys c n</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">appendChurch' ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a
appendChurch' (<span class="dt">Church</span> fx) (<span class="dt">Church</span> fy) <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> fx c <span class="fu">.</span> fy c</code></pre></div>
</div>
<div id="the-basic-idea-4" class="slide section level1">
<h1>The Basic Idea</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
[]     <span class="fu">++</span> bs <span class="fu">=</span> bs
(a<span class="fu">:</span>as) <span class="fu">++</span> bs <span class="fu">=</span> a <span class="fu">:</span> (as <span class="fu">++</span> bs)

<span class="co">-- call `:` once per element of the first list, every time you call `++`!</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">appendChurch' ::</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a <span class="ot">-&gt;</span> <span class="dt">Church</span> a
appendChurch' (<span class="dt">Church</span> fx) (<span class="dt">Church</span> fy) <span class="fu">=</span> <span class="dt">Church</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> fx c <span class="fu">.</span> fy c

<span class="co">-- run one function composition per call to `appendChurch'`!</span></code></pre></div>
</div>
<div id="the-basic-idea-5" class="slide section level1">
<h1>The Basic Idea</h1>
<p>Also applies to other practical problems.</p>
<blockquote>
<p>04:38:09 bkolera | It wouldn't be a big deal if we didn't encode sum types as</p>
</blockquote>
<blockquote>
<pre><code>                      | sub types in scala, but ... &gt;_&gt;</code></pre>
</blockquote>
<blockquote>
<p>04:42:56 georgew | You could just Church encode?</p>
</blockquote>
</div>
<div id="embedded-domain-specific-languages" class="slide section level1">
<h1>Embedded Domain-Specific Languages</h1>
<p>Now that we've seen a simple example of what representing our data as functions might mean and how it might help us, let's think about a more general case. One common approach to problem solving in functional programming is to define a small <strong>domain-specific language</strong> (DSL) in which to represent the problem or class of problems we're interested in attacking. Calling a DSL <strong>embedded</strong> means that rather than have a separate parser, typechecker, etc. for our new language, we're going to just write regular programs with whatever language we like, but ideally make it look like and work like a language on its own. EDSL programs are just regular programs. We can then provide a way to run programs written in this so-called &quot;object language&quot; in our &quot;meta language&quot; (e.g. Haskell or OCaml, or some very general purpose language with a great type system and compiler to do the heavy lifting). This approach can help decouple the problem domain from the engineering required to make it happen cleanly and efficiently on the computer. Let's look at some common considerations when implementing a domain-specific language.</p>
</div>
<div id="the-multiple-interpretations-problem" class="slide section level1">
<h1>The Multiple Interpretations Problem</h1>
<p>A common design goal when implementing a DSL is that you'd like to be able to interpret the same program in different ways. The obvious way is:</p>
<ul>
<li>Run the program and get its result</li>
</ul>
<p>But there are other ways, for example:</p>
<ul>
<li><p>Pretty-print or serialize the program</p></li>
<li><p>Perform optimizations before executing the program</p></li>
<li><p>Run additional checks or pre-run tests (particularly if the language allows side effects outside the type system).</p></li>
<li><p>Generate code, e.g. spit out C or Javascript so our program can be run in restricted environments.</p></li>
<li><p>Execute using alternative evaluation strategies, e.g. using the LLVM JIT compilation tools to speed up execution or running the program on a GPU.</p></li>
</ul>
</div>
<div id="the-expression-problem" class="slide section level1">
<h1>The Expression Problem</h1>
<blockquote>
<p>The Expression Problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).</p>
</blockquote>
<p>-- Philip Wadler, Nov. 1998</p>
<p>In other words, we'd like to be able to extend a DSL without having to modify its core. This can allow users to extend the language themselves or to provide new features without breaking existing systems.</p>
</div>
<div id="the-static-safety-problem" class="slide section level1">
<h1>The Static Safety Problem</h1>
<p>A common design goal when implementing an embedded DSL is that we'd like to take advantage of our metalanguage's facilities where we can. In particular, if we're building a fairly simple language, it would be very convenient to be able to lean on the sophisticated type checker of the metalanguage at compile time. A downside is that the error messages may be clearer to the implementer than the user, but the upside is that we can catch errors in the DSL at compile time with a lot less work than if we implemented our own type checker. The same kinds of advantages can apply for debugging tools, code generation, etc.</p>
</div>
<div id="solving-all-the-problems-at-once" class="slide section level1">
<h1>Solving All The Problems At Once</h1>
<p>I'm now going to introduce the technique from &quot;Finally Tagless,&quot; which solves these problems quite nicely. Later, we'll also discuss some other advantages and disadvantages to the different representations. We're going to start with some code that exhibits some of the problems and work our way towards the solution. To begin, let's look at our data in the ordinary way.</p>
</div>
<div id="a-simple-but-powerful-dsl" class="slide section level1">
<h1>A Simple (But Powerful) DSL</h1>
<p>To illustrate how representing data differently can be applied to building DSLs, let's take the simply-typed lambda calculus, with integers as the base type, as a running example. The STLC is a good example because it has first-class functions, so we'll make sure our results apply to higher-order languages.</p>
<p>Unfortunately I must use de Bruijn indices, as I haven't figured out how to use higher-order abstract syntax with plain ADTs. The later examples will involve less binding-related machinery.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Simply-typed lambda calculus terms</span>
<span class="kw">data</span> <span class="dt">STLCTerm</span> <span class="fu">=</span> <span class="dt">SVar</span> <span class="dt">Var</span>
              <span class="fu">|</span> <span class="dt">SNum</span> <span class="dt">Int</span>
              <span class="fu">|</span> <span class="dt">SApp</span> <span class="dt">STLCTerm</span> <span class="dt">STLCTerm</span>
              <span class="fu">|</span> <span class="dt">SLam</span> <span class="dt">STLCTerm</span>
              <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- Representation of evaluation environments</span>
<span class="kw">data</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">VZero</span> <span class="fu">|</span> <span class="dt">VSucc</span> <span class="dt">Var</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- We need a way to look up variables in our environment.</span>
<span class="ot">lkup ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> [x] <span class="ot">-&gt;</span> x
lkup <span class="dt">VZero</span> [x] <span class="fu">=</span> x
lkup (<span class="dt">VSucc</span> v) (_<span class="fu">:</span>moar) <span class="fu">=</span> lkup v moar
lkup _ _ <span class="fu">=</span> error <span class="st">&quot;sorry, dawg; I can't interpret an open term!&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC env (<span class="dt">SNum</span> i) <span class="fu">=</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> (evalSTLC env f) (evalSTLC env x)
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">testSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)</code></pre></div>
</div>
<div id="a-simple-but-powerful-dsl-1" class="slide section level1">
<h1>A Simple (But Powerful) DSL</h1>
<p>What a puzzling error!</p>
<pre class="text"><code>[1 of 1] Compiling FinallyTagless   ( FinallyTagless.hs, interpreted )

FinallyTagless.hs:122:27:
    Couldn't match expected type Int -&gt; Int with actual type Int
    The function evalSTLC is applied to three arguments,
    but its type [Int] -&gt; STLCTerm -&gt; Int has only two
    In the expression: (evalSTLC env f) (evalSTLC env x)
    In an equation for evalSTLC:
        evalSTLC env (SApp f x) = (evalSTLC env f) (evalSTLC env x)

FinallyTagless.hs:123:25:
    Couldn't match expected type Int -&gt; Int with actual type Int
    The lambda expression \ x -&gt; evalSTLC (x : env) b
    has one argument,
    but its type Int has none
    In the expression: \ x -&gt; evalSTLC (x : env) b
    In an equation for evalSTLC:
        evalSTLC env (SLam b) = \ x -&gt; evalSTLC (x : env) b
Failed, modules loaded: none.</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- What type do we give this?  What's the return type?</span>
evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC env (<span class="dt">SNum</span> i) <span class="fu">=</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> (evalSTLC env f) (evalSTLC env x)
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b</code></pre></div>
<p>This can't work; the resulting expression might be either an <code>SLam</code> or an <code>SNum</code>. We can't put both into our environment or return both! So we have to introduce a &quot;tag&quot; to wrap the possible values and indicate which we're dealing with.</p>
</div>
<div id="a-less-simple-but-still-powerful-dsl" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tag</span> <span class="fu">=</span> <span class="dt">IntTag</span> <span class="dt">Int</span>
         <span class="fu">|</span> <span class="dt">LambdaTag</span> (<span class="dt">Tag</span> <span class="ot">-&gt;</span> <span class="dt">Tag</span>)

<span class="ot">evalSTLC ::</span> [<span class="dt">Tag</span>] <span class="ot">-&gt;</span> <span class="dt">STLCTerm</span> <span class="ot">-&gt;</span> <span class="dt">Tag</span>
evalSTLC env (<span class="dt">SVar</span> v) <span class="fu">=</span> lkup v env
evalSTLC _   (<span class="dt">SNum</span> i) <span class="fu">=</span> <span class="dt">IntTag</span> i
evalSTLC env (<span class="dt">SApp</span> f x) <span class="fu">=</span> go (evalSTLC env f)
  <span class="kw">where</span>
    evx <span class="fu">=</span> evalSTLC env x
    go (<span class="dt">LambdaTag</span> f') <span class="fu">=</span> f' evx
    go z             <span class="fu">=</span>
      error <span class="fu">$</span> <span class="st">&quot;Can't apply the non-function '&quot;</span> <span class="fu">++</span> show z <span class="fu">++</span>
      <span class="st">&quot;' to argument '&quot;</span> <span class="fu">++</span> show evx <span class="fu">++</span> <span class="st">&quot;'!&quot;</span>
evalSTLC env (<span class="dt">SLam</span> b) <span class="fu">=</span> <span class="dt">LambdaTag</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> evalSTLC (x <span class="fu">:</span> env) b

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Tag</span> <span class="kw">where</span>
  show (<span class="dt">IntTag</span> i) <span class="fu">=</span> <span class="st">&quot;&lt;&quot;</span> <span class="fu">++</span> show i <span class="fu">++</span> <span class="st">&quot; :: Int&gt;&quot;</span>
  show (<span class="dt">LambdaTag</span> _) <span class="fu">=</span> <span class="st">&quot;&lt;lambda&gt;&quot;</span>

<span class="co">-- our test program: (x.x) 22</span>
testSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)</code></pre></div>
<p>This code typechecks and runs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> testSTLC
<span class="dt">SApp</span> (<span class="dt">SLam</span> (<span class="dt">SVar</span> <span class="dt">VZero</span>)) (<span class="dt">SNum</span> <span class="dv">22</span>)
<span class="fu">&gt;</span> evalSTLC [] testSTLC
<span class="fu">&lt;</span><span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Int</span><span class="fu">&gt;</span></code></pre></div>
</div>
<div id="a-less-simple-but-still-powerful-dsl-1" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<p>Sadly, we have to introduce this tag to get things to typecheck. The interpreter is less clear and less direct. In addition</p>
<ul>
<li><p>We have some runtime overhead due to pattern-matching on the tag</p></li>
<li><p>The interpreter is partial!</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failSTLC <span class="fu">=</span> <span class="dt">SApp</span> (<span class="dt">SNum</span> <span class="dv">22</span>) (<span class="dt">SNum</span> <span class="dv">33</span>)

<span class="fu">&gt;</span> evalSTLC [] failSTLC
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Can't</span> apply the non<span class="fu">-</span>function <span class="ch">'&lt;22 :: Int&gt;'</span> to argument <span class="ch">'&lt;33 :: Int&gt;'</span><span class="fu">!</span></code></pre></div>
<p>This term is nonsensical, but it compiled just fine.</p>
</div>
<div id="a-less-simple-but-still-powerful-dsl-2" class="slide section level1">
<h1>A Less Simple (But Still Powerful) DSL</h1>
<p>This interpreter solves the Multiple Interpretations Problem. We can take an <code>STLCTerm</code> and pass it around, manipulate it, optimize it, pretty-print it, etc.</p>
<p>This interpreter does not solve the Expression Problem. To extend the language, we have to open up this file, change the definition of <code>STLCTerm</code> and rewrite a bunch of code to match. Our compiler should help highlight what we need to update, but it's still not satisfactory.</p>
<p>This interpreter does not solve the Static Safety Problem. The language is extremely simple, but our implementation doesn't let us lean on Haskell's type checker. We have to write our own.</p>
</div>
<div id="a-tagless-encoding" class="slide section level1">
<h1>A Tagless Encoding</h1>
<p>Let's tackle the Static Safety Problem by using Generalised Algebraic Data Types (GADTs).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> t <span class="kw">where</span>
  <span class="co">-- This quantified type could be a particular type like `Int`, but</span>
  <span class="co">-- I'm using anything I can `show` just to make interactive</span>
  <span class="co">-- debugging easier</span>
  <span class="dt">Const</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Var</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Term</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Lam</span><span class="ot"> ::</span> (<span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (b <span class="ot">-&gt;</span> a)

<span class="ot">eval ::</span> <span class="dt">Term</span> t <span class="ot">-&gt;</span> t
eval (<span class="dt">Var</span> x) <span class="fu">=</span> x
eval (<span class="dt">Const</span> x) <span class="fu">=</span> x
eval (<span class="dt">App</span> f x) <span class="fu">=</span> eval f (eval x)
eval (<span class="dt">Lam</span> f) <span class="fu">=</span> eval <span class="fu">.</span> f <span class="fu">.</span> <span class="dt">Var</span></code></pre></div>
<p>Well, that was easy. Let's try some test programs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">first <span class="fu">=</span> <span class="dt">Lam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

twice <span class="fu">=</span> <span class="dt">Lam</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">Lam</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`App`</span> (f <span class="ot">`App`</span> x <span class="ot">`App`</span> y) <span class="ot">`App`</span> y

pairs <span class="fu">=</span> twice <span class="ot">`App`</span> first <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">33</span>) <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">22</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eval pairs
<span class="dv">33</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a</code></pre></div>
<p>I'm not sure it was worth computing, but it worked fine.</p>
</div>
<div id="a-tagless-encoding-1" class="slide section level1">
<h1>A Tagless Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failure <span class="fu">=</span> twice <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">33</span>) <span class="ot">`App`</span> (<span class="dt">Const</span> <span class="dv">22</span>) <span class="ot">`App`</span> first</code></pre></div>
<pre class="text"><code>FinallyTagless.hs:210:1:
    Could not deduce (Num (a -&gt; (a0 -&gt; b0 -&gt; a0) -&gt; a))
    from the context (Num a,
                      Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a),
                      Show a,
                      Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a))
      bound by the inferred type for failure:
                 (Num a, Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a), Show a,
                  Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a)) =&gt;
                 Term a
      at FinallyTagless.hs:210:1-61
    The type variables b0, a0 are ambiguous
    When checking that failure has the inferred type
      failure :: forall a b a1.
                 (Num a, Num (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a), Show a,
                  Show (a -&gt; (a1 -&gt; b -&gt; a1) -&gt; a)) =&gt;
                 Term a
    Probable cause: the inferred type is ambiguous</code></pre>
<p>It looks like we've licked the static safety problem!</p>
<p>This interpreter also solves the Multiple Interpretations Problem (just write any function that pattern-matches on the constructors of <code>Term</code>).</p>
</div>
<div id="a-tagless-encoding-2" class="slide section level1">
<h1>A Tagless Encoding</h1>
<p>Unfortunately, this GADT-based interpreter is the same as the previous interpreter with respect to the Expression Problem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Users want Turing-completeness.  Management has demanded we add a</span>
<span class="co">-- fixpoint combinator without breaking any existing code!</span>

<span class="kw">data</span> <span class="dt">TermY</span> t <span class="kw">where</span>
  <span class="dt">ConstY</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">VarY</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">AppY</span><span class="ot"> ::</span> <span class="dt">TermY</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> b <span class="ot">-&gt;</span> <span class="dt">TermY</span> a
  <span class="dt">LamY</span><span class="ot"> ::</span> (<span class="dt">TermY</span> b <span class="ot">-&gt;</span> <span class="dt">TermY</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> (b <span class="ot">-&gt;</span> a)
  <span class="dt">Y</span><span class="ot">    ::</span> <span class="dt">TermY</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">TermY</span> a

<span class="ot">evalY ::</span> <span class="dt">TermY</span> t <span class="ot">-&gt;</span> t
evalY (<span class="dt">VarY</span> x) <span class="fu">=</span> x
evalY (<span class="dt">ConstY</span> x) <span class="fu">=</span> x
evalY (<span class="dt">AppY</span> f x) <span class="fu">=</span> evalY f (evalY x)
evalY (<span class="dt">LamY</span> f) <span class="fu">=</span> evalY <span class="fu">.</span> f <span class="fu">.</span> <span class="dt">VarY</span>
evalY (<span class="dt">Y</span> f) <span class="fu">=</span> y' <span class="fu">$</span> evalY f
  <span class="kw">where</span>
    y' g <span class="fu">=</span> g <span class="fu">$</span> y' g

twiceY <span class="fu">=</span> <span class="dt">LamY</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">LamY</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">LamY</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`AppY`</span> (f <span class="ot">`AppY`</span> x <span class="ot">`AppY`</span> y) <span class="ot">`AppY`</span> y</code></pre></div>
<p>Ugh, we've got to rewrite everything! Management is disappointed.</p>
<p>At this point, I hope it's clear that to solve the Expression Problem, we can't simply use ordinary data types with constructors directly. We'll never be able to extend them in a separate module. Let's try a different approach, motivated by our earlier look at Church encoding.</p>
</div>
<div id="a-final-encoding" class="slide section level1">
<h1>A Final Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eval</span> {<span class="ot"> eval ::</span> a }

<span class="ot">var ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
var <span class="fu">=</span> <span class="dt">Eval</span>

<span class="ot">app ::</span> <span class="dt">Eval</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eval</span> b <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
app (<span class="dt">Eval</span> f) (<span class="dt">Eval</span> x) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> f x

<span class="ot">lam ::</span> (<span class="dt">Eval</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> b) <span class="ot">-&gt;</span> <span class="dt">Eval</span> (a <span class="ot">-&gt;</span> b)
lam b <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> eval (b (<span class="dt">Eval</span> x))</code></pre></div>
<p>We can do a similar trick to the Church encoding of lists and represent our data constructors as functions. This is <strong>not</strong> a Church encoding; it's called a <strong>final encoding</strong> for reasons unknown to me. The version using explicit constructors is called an <strong>initial encoding</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- first = Lam $ \x -&gt; Lam $ \y -&gt; x</span>
first <span class="fu">=</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

<span class="co">-- twice = Lam $ \f -&gt; Lam $ \x -&gt; Lam $ \y -&gt; f `App` (f `App` x `App` y) `App` y</span>
twice <span class="fu">=</span> lam <span class="fu">$</span> \f <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`app`</span> (f <span class="ot">`app`</span> x <span class="ot">`app`</span> y) <span class="ot">`app`</span> y

<span class="co">-- pairs = twice `App` first `App` (Const 33) `App` (Const 22)</span>
pairs <span class="fu">=</span> twice <span class="ot">`app`</span> first <span class="ot">`app`</span> var <span class="dv">33</span> <span class="ot">`app`</span> var <span class="dv">22</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Eval</span> a

<span class="fu">&gt;</span> eval pairs
<span class="dv">33</span></code></pre></div>
<p>The new encoding works, and it's quite similar to the original! Let's see how we do on the various problems.</p>
</div>
<div id="a-final-encoding-1" class="slide section level1">
<h1>A Final Encoding</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">failure <span class="fu">=</span> twice <span class="ot">`app`</span> (var <span class="dv">33</span>) <span class="ot">`app`</span> (var <span class="dv">22</span>) <span class="ot">`app`</span> first

FinallyTagless.hs<span class="fu">:</span><span class="dv">72</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span>
    <span class="dt">Non</span> <span class="kw">type</span><span class="fu">-</span>variable argument
      <span class="kw">in</span> the constraint<span class="fu">:</span> <span class="dt">Num</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a)
    (<span class="dt">Use</span> <span class="dt">FlexibleContexts</span> to permit this)
    <span class="dt">When</span> checking that failure has the inferred <span class="kw">type</span>
<span class="ot">      failure ::</span> forall a a1 b<span class="fu">.</span>
                 (<span class="dt">Num</span> a, <span class="dt">Num</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a1 <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a), <span class="dt">Show</span> a,
                  <span class="dt">Show</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a1 <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a)) <span class="ot">=&gt;</span>
                 <span class="dt">Eval</span> a</code></pre></div>
<p>Lovely! This final encoding solves the Static Safety Problem.</p>
</div>
<div id="a-final-encoding-2" class="slide section level1">
<h1>A Final Encoding</h1>
<p>Now we can extend our object language in a different module, without touching the original.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span>Final.hs (<span class="dt">Eval</span>(..), lam, app, var)

<span class="ot">y ::</span> <span class="dt">Eval</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
y (<span class="dt">Eval</span> f) <span class="fu">=</span> <span class="dt">Eval</span> (y' f)
  <span class="kw">where</span>
    y' g <span class="fu">=</span> g <span class="fu">$</span> y' g

twentytwo <span class="fu">=</span> y <span class="fu">$</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> const (var <span class="dv">22</span>) x</code></pre></div>
<p>Let's try it out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eval <span class="fu">$</span> twentytwo
<span class="dv">22</span></code></pre></div>
<p>Hooray! This interpreter solves the Expression Problem! Management is satisfied! But . . .</p>
</div>
<div id="a-final-encoding-3" class="slide section level1">
<h1>A Final Encoding</h1>
<p>How do we solve the Multiple Interpretations Problem? There's nothing we can change about the way we interpret our code. Optimization is right out! This leaves our users unhappy again.</p>
<p>We solved the Expression Problem by representing our data as functions, but now we want our functions to have different meanings. Can you think of a way to give functions different meanings, depending on some context? Depending on the type?</p>
</div>
<div id="the-finally-tagless-solution" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<p>The answer, in Haskell, is to use type classes. (In OCaml, you can do the same thing with a module.) This type class defines the lambda calculus language:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FinalTerm</span> repr <span class="kw">where</span>
<span class="ot">  var ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> repr a
<span class="ot">  app ::</span> repr (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> repr b <span class="ot">-&gt;</span> repr a
<span class="ot">  lam ::</span> (repr a <span class="ot">-&gt;</span> repr b) <span class="ot">-&gt;</span> repr (a <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Now we can make an instance for evaluation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Eval</span> {<span class="ot"> eval ::</span> a }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> <span class="dt">Eval</span> <span class="kw">where</span>
  var x <span class="fu">=</span> <span class="dt">Eval</span> x
  app (<span class="dt">Eval</span> f) (<span class="dt">Eval</span> x) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> f x
  lam b <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> eval' (b (<span class="dt">Eval</span> x))</code></pre></div>
<p>Our test programs are unchanged.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">first <span class="fu">=</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> x

twice <span class="fu">=</span> lam <span class="fu">$</span> \f <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> f <span class="ot">`app`</span> (f <span class="ot">`app`</span> x <span class="ot">`app`</span> y) <span class="ot">`app`</span> y

pairs <span class="fu">=</span> twice <span class="ot">`app`</span> first <span class="ot">`app`</span> var <span class="dv">33</span> <span class="ot">`app`</span> var <span class="dv">22</span>

<span class="fu">&gt;</span> <span class="fu">:</span>t pairs
<span class="ot">pairs ::</span> (<span class="dt">Num</span> a, <span class="dt">Show</span> a, <span class="dt">FinalTerm</span> repr) <span class="ot">=&gt;</span> repr a

<span class="fu">&gt;</span> eval pairs
<span class="dv">33</span></code></pre></div>
</div>
<div id="the-finally-tagless-solution-1" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<p>We can also make a second interpreter: a pretty-printer!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This is just machinery for generating variable names</span>
<span class="ot">varnames ::</span> [<span class="dt">String</span>]
varnames <span class="fu">=</span> <span class="st">&quot;xyzwabcdefghmnpqrstu&quot;</span>

parens [] <span class="fu">=</span> <span class="st">&quot;()&quot;</span>
parens str
  <span class="fu">|</span> head str <span class="fu">==</span> <span class="ch">'('</span> <span class="fu">&amp;&amp;</span> last str <span class="fu">==</span> <span class="ch">')'</span> <span class="fu">=</span> str
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="co">-- Here is the new type we use to choose the instance we want.</span>
<span class="kw">newtype</span> <span class="dt">Pretty</span> a <span class="fu">=</span> <span class="dt">Pretty</span> {<span class="ot"> unPretty ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> <span class="dt">Pretty</span> <span class="kw">where</span>
  var <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">.</span> const <span class="fu">.</span> show
  lam f <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \(v<span class="fu">:</span>vs) <span class="ot">-&gt;</span> parens <span class="fu">$</span>
    <span class="st">&quot;lambda &quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;. &quot;</span> <span class="fu">++</span> unPretty (f (<span class="dt">Pretty</span> <span class="fu">$</span> const v)) vs
  app (<span class="dt">Pretty</span> f) (<span class="dt">Pretty</span> x) <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \c <span class="ot">-&gt;</span> parens <span class="fu">$</span> f c <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> x c

<span class="ot">pretty ::</span> <span class="dt">Pretty</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
pretty expr <span class="fu">=</span> unPretty expr varnames</code></pre></div>
<p>Let's run the test program through it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> pretty' pairs
<span class="st">&quot;(((lambda x. (lambda y. (lambda z. ((x ((x y) z)) z)))) (lambda x. (lambda y. x)) 33) 22)&quot;</span></code></pre></div>
</div>
<div id="the-finally-tagless-solution-2" class="slide section level1">
<h1>The Finally Tagless Solution</h1>
<p>We've already shown that we can solve the Multiple Interpretations Problem, and the Static Safety Problem is solved just as with functions. Now let's see how this approach addresses the Expression Problem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span>FinallyTagless.hs (<span class="dt">FinalTerm</span>(..), <span class="dt">Eval</span>(..), <span class="dt">Pretty</span>(..), pretty)

<span class="kw">class</span> <span class="dt">FinalTermY</span> repr <span class="kw">where</span>
<span class="ot">  y ::</span> repr (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> repr a

<span class="kw">instance</span> <span class="dt">FinalTermY</span> <span class="dt">Eval</span> <span class="kw">where</span>
  y (<span class="dt">Eval</span> f) <span class="fu">=</span> <span class="dt">Eval</span> <span class="fu">$</span> y' f
    <span class="kw">where</span>
      y' g <span class="fu">=</span> g <span class="fu">$</span> y' g

<span class="kw">instance</span> <span class="dt">FinalTermY</span> <span class="dt">Pretty</span> <span class="kw">where</span>
  y (<span class="dt">Pretty</span> f) <span class="fu">=</span> <span class="dt">Pretty</span> <span class="fu">$</span> \names<span class="fu">@</span>(v<span class="fu">:</span>_) <span class="ot">-&gt;</span>
    parens <span class="fu">$</span> <span class="st">&quot;fixpoint of &quot;</span> <span class="fu">++</span> f names <span class="fu">++</span> <span class="st">&quot; with respect to '&quot;</span> <span class="fu">++</span> v <span class="fu">++</span> <span class="st">&quot;'&quot;</span></code></pre></div>
<p>This is not an insubstantial addition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">twentytwo <span class="fu">=</span> y <span class="fu">$</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> const (var <span class="dv">22</span>) x

<span class="fu">&gt;</span> eval twentytwo
<span class="dv">22</span>

<span class="fu">&gt;</span> pretty twentytwo
<span class="st">&quot;(fixpoint of (lambda x. 22) with respect to 'x')&quot;</span></code></pre></div>
<p>You may have noticed that in these cases, type inference also works perfectly fine, and we haven't used anything outside Haskell 98.</p>
</div>
<div id="equivalence-of-final-and-initial-encodings" class="slide section level1">
<h1>Equivalence Of Final and Initial Encodings</h1>
<p>We can convert back and forth between encodings to show that they are equivalent. There is a catch, though; if we used our old initial encoding (the <code>Term</code> GADT), we'd have to commit to a particular final interpretation, e.g. <code>Eval</code> or <code>Pretty</code>. Instead, I've defined this new initial encoding containing the <code>HCell</code> constructor. This constructor lets us work with terms that have already been &quot;finally encoded&quot; in our initial representation. It doesn't show up in any programs, but it's necessary to write <code>evalH</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HTerm</span> h t <span class="kw">where</span>
  <span class="dt">HVar</span><span class="ot"> ::</span> <span class="dt">Show</span> t <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h t
  <span class="dt">HCell</span><span class="ot"> ::</span> h t <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h t
  <span class="dt">HApp</span><span class="ot"> ::</span> <span class="dt">HTerm</span> h (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h a <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h b
  <span class="dt">HLam</span><span class="ot"> ::</span> (<span class="dt">HTerm</span> h a <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h b) <span class="ot">-&gt;</span> <span class="dt">HTerm</span> h (a <span class="ot">-&gt;</span> b)

<span class="co">-- An interpreter for Eval</span>
<span class="ot">evalH ::</span> <span class="dt">HTerm</span> <span class="dt">Eval</span> t <span class="ot">-&gt;</span> t
evalH (<span class="dt">HVar</span> x) <span class="fu">=</span> x
evalH (<span class="dt">HApp</span> f x) <span class="fu">=</span> evalH f (evalH x)
evalH (<span class="dt">HCell</span> x) <span class="fu">=</span> eval' x
evalH (<span class="dt">HLam</span> b) <span class="fu">=</span> evalH <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span> <span class="fu">.</span> <span class="dt">Eval</span>

<span class="co">-- Now we can convert from final to initial:</span>
<span class="kw">instance</span> <span class="dt">FinalTerm</span> (<span class="dt">HTerm</span> h) <span class="kw">where</span>
  var <span class="fu">=</span> <span class="dt">HVar</span>
  app <span class="fu">=</span> <span class="dt">HApp</span>
  lam <span class="fu">=</span> <span class="dt">HLam</span>

<span class="co">-- and from initial to final:</span>
<span class="ot">convert ::</span> (<span class="dt">FinalTerm</span> repr) <span class="ot">=&gt;</span> <span class="dt">HTerm</span> repr t <span class="ot">-&gt;</span> repr t
convert (<span class="dt">HVar</span> x) <span class="fu">=</span> var x
convert (<span class="dt">HCell</span> x) <span class="fu">=</span> x
convert (<span class="dt">HApp</span> f x) <span class="fu">=</span> app (convert f) (convert x)
convert (<span class="dt">HLam</span> b) <span class="fu">=</span> lam <span class="fu">$</span> convert <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span></code></pre></div>
<p>Notice that when you convert to or from a particular initial encoding, your language becomes 'closed' again. The initial encoding for the language and the conversion code above would have to be modified if we wanted to convert terms using the Y combinator.</p>
</div>
<div id="drawbacks" class="slide section level1">
<h1>Drawbacks</h1>
<p>The Finally Tagless approach to EDSL implementation solves the Static Safety Problem, the Multiple Interpreters Problem and the Expression Problem all at once. Management is happy; users are happy; we're happy. Is it the end of the talk?</p>
<p>There are some disadvantages . . .</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runAndPrettyPrint prog <span class="fu">=</span> (eval' prog, pretty' prog)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">42</span><span class="fu">:</span>
    <span class="dt">Couldn't</span> match expected <span class="kw">type</span> <span class="dt">Pretty</span> a0 with actual <span class="kw">type</span> <span class="dt">Eval</span> t
    <span class="dt">Relevant</span> bindings include
<span class="ot">      t ::</span> <span class="dt">Eval</span> t (bound at FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">20</span>)
<span class="ot">      runAndPrettyPrint' ::</span> <span class="dt">Eval</span> t <span class="ot">-&gt;</span> (t, <span class="dt">String</span>)
        (bound at FinallyTagless.hs<span class="fu">:</span><span class="dv">402</span><span class="fu">:</span><span class="dv">1</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> pretty', namely t
    <span class="dt">In</span> the expression<span class="fu">:</span> pretty' t</code></pre></div>
<p>What is this about?! Couldn't match <code>Pretty a0</code> with <code>Eval t</code>?</p>
<p>This problem occurs with any function that produces or accepts a finally-encoded program; Oleg describes this by saying that &quot;polymorphism in Haskell is not first-class&quot; -- when we pattern-match on the program, we constrain it to a single type. Alas!</p>
<p>We can use this <code>Program</code> wrapper if we want to output a program in our object language. This achieves the goal of allowing multiple interpretations, but at a price: the representation is now closed, since we had to explicitly list what parts of the language we want to quantify over. In this example, we have excluded the fixpoint combinator from the language!</p>
<p>In addition, wrapping up object language programs with a <code>forall</code> also causes issues for the isomorphism function above (I think); I can't work out how to write a function that takes an <code>HTerm repr t</code> and converts it to a <code>Program t</code>. We need the <code>repr</code> argument to <code>HTerm</code> to be quantified the same way as the one hidden inside the <code>Program</code>.</p>
</div>
<div id="drawbacks-1" class="slide section level1">
<h1>Drawbacks</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE ImpredicativeTypes #-}</span>

<span class="kw">newtype</span> <span class="dt">Program</span> a <span class="fu">=</span> <span class="dt">Program</span> {
<span class="ot">  getProgram ::</span> forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> repr a
  }

<span class="ot">convert' ::</span> <span class="dt">HTerm</span> (forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt; repr ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) t
         <span class="ot">-&gt;</span> (forall repr<span class="fu">.</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> repr t)
convert' (<span class="dt">HVar</span> x) <span class="fu">=</span> var x
convert' (<span class="dt">HCell</span> x) <span class="fu">=</span> x
convert' (<span class="dt">HApp</span> f x) <span class="fu">=</span> app (convert' f) (convert' x)
convert' (<span class="dt">HLam</span> b) <span class="fu">=</span> lam <span class="fu">$</span> convert' <span class="fu">.</span> b <span class="fu">.</span> <span class="dt">HCell</span></code></pre></div>
<p>If we used the ImpredicativeTypes extension, which lets us write things like this, we could solve the problem. Sadly, GHC would no longer be able to infer types for such values. That's a heavy price to pay!</p>
</div>
<div id="drawbacks-2" class="slide section level1">
<h1>Drawbacks</h1>
<p>Remember, the only thing we can do with a finally-encoded term is to interpret it. So if we want to use it for multiple things, can we make an interpreter that provides multiple instances of the program? This is indeed Oleg's solution to the problem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Pair</span> repr repr' t <span class="fu">=</span> <span class="dt">Pair</span> {<span class="ot"> unPair ::</span> (repr t, repr' t) }

<span class="kw">instance</span> (<span class="dt">FinalTerm</span> repr, <span class="dt">FinalTerm</span> repr') <span class="ot">=&gt;</span> <span class="dt">FinalTerm</span> (<span class="dt">Pair</span> repr repr') <span class="kw">where</span>
  var x <span class="fu">=</span> <span class="dt">Pair</span> (var x, var x)
  app f x <span class="fu">=</span> <span class="kw">let</span> (f', f'') <span class="fu">=</span> unPair f
                (x', x'') <span class="fu">=</span> unPair x
            <span class="kw">in</span> <span class="dt">Pair</span> (app f' x', app f'' x'')
  lam b <span class="fu">=</span> <span class="dt">Pair</span> (lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> fst <span class="fu">.</span> unPair <span class="fu">.</span> b <span class="fu">$</span> <span class="dt">Pair</span> (x, undefined),
                lam <span class="fu">$</span> \z <span class="ot">-&gt;</span> snd <span class="fu">.</span> unPair <span class="fu">.</span> b <span class="fu">$</span> <span class="dt">Pair</span> (undefined, z))</code></pre></div>
<p>Equipped with this somewhat clunky tool, we can now build <code>runAndPrettyPrint</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runAndPrettyPrint prog <span class="fu">=</span> (eval' <span class="fu">$</span> l prog, pretty' <span class="fu">$</span> r prog)
  <span class="kw">where</span>
    l <span class="fu">=</span> fst <span class="fu">.</span> unPair
    r <span class="fu">=</span> snd <span class="fu">.</span> unPair</code></pre></div>
<p>We're still in Haskell 98 land, and type inference still works properly!</p>
</div>
<div id="other-drawbacks" class="slide section level1">
<h1>Other Drawbacks</h1>
<p>The &quot;Finally Tagless&quot; paper shows how to apply the approach to various other useful tasks, like deserialization of the program (which includes type-checking), performing optimizations by transforming the AST, type-directed partial evaluation, and more. Those things are possible (and TDPE is pretty neat), but frankly, it would be a slog to just show how most of them work (I have backup slides if you're interested). For the sake of time and not just blasting more code on the screen, I'm going to summarize the tradeoffs as I understand them here.</p>
</div>
<div id="initial-advantages" class="slide section level1">
<h1>Initial Advantages</h1>
<p>Here are some advantages of the ADT method, also known as the &quot;initial&quot; encoding of the language:</p>
<ul>
<li><p>We can pattern-match on the ADT, which makes transforming the representation of the embedded program straightforward to understand (e.g. if we want to do some optimizations). It's also amenable to existing generic programming tools like 'uniplate' or 'syb'.</p></li>
<li><p>Defining a &quot;tagless&quot; ADT usually requires additional type system features, e.g. GADTs, but once the ADT is defined and we accept that we need an enhanced type system, object language programs are automatically first-class without any additional machinery. (We don't need the weird &quot;duplicating interpreter&quot;.)</p></li>
<li><p>If you want to make your initially-encoded language no longer embedded directly in the meta language (e.g. moving to a dependently-typed language, with a separate type checker), the extension is fairly natural. I haven't seen or come up with any clean ways of doing this for finally-encoded ones.</p></li>
</ul>
</div>
<div id="final-advantages" class="slide section level1">
<h1>Final Advantages</h1>
<p>Here are some advantages of the typeclass method, also known as the &quot;final&quot; encoding of the language:</p>
<ul>
<li><p>Our language is extensible and open; we can add new features to its abstract syntax while reusing, without modifying (or even recompiling!) the code for the core language. GHC can infer the object program types at the use site. It's possible to solve the Expression Problem.</p></li>
<li><p>With some usage patterns, especially the typical &quot;monadic substitution&quot; pattern that happens when language fragments are composed together, a final encoding (with or without type classes) can actually yield an asymptotic speedup in creating the program.</p></li>
<li><p>It is possible to solve the Static Safety Problem in Haskell 98.</p></li>
</ul>
</div>
<div id="other-notes" class="slide section level1">
<h1>Other Notes</h1>
<ul>
<li><p>I've tried to attack the same three EDSL design problems using some of the &quot;coproducts for free&quot; machinery that Dave has written about. Unfortunately, I'm currently stumped trying to apply it to higher-order languages, and it seems to require an awful lot of machinery. Maybe Dave can do a follow-up talk explaining how this can be done nicely!</p></li>
<li><p>It's worth pointing out that Oleg and others have constructed DSLs with linear typing using this approach. This is noteworthy because linear types are not a strict subset of Haskell's or OCaml's type system.</p></li>
<li><p>I've used HOAS for all the examples, but the final approach using type classes can be done perfectly fine with de Bruijn indices as well. You can convert from de Bruijn to HOAS pretty straightforwardly. I think the other direction is a lot harder, if it's possible.</p></li>
</ul>
</div>
<div id="conclusion" class="slide section level1">
<h1>Conclusion</h1>
<p>If you haven't seen this material before, I hope this talk has introduced a different perspective on programs and domain-specific languages.</p>
</div>
<div id="backups" class="slide section level1">
<h1>Backups</h1>
</div>
<div id="de-bruijn-indices-finally-encoded" class="slide section level1">
<h1>De Bruijn Indices, Finally Encoded</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FinalDBTerm</span> repr <span class="kw">where</span>
<span class="ot">  dbvar ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbapp ::</span> repr env (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env b
  <span class="co">-- The type of 'dblam' is pretty different from the type of the HOAS</span>
  <span class="co">-- method 'lam'.  If you think about how 'EvalEnv' is defined, it</span>
  <span class="co">-- makes sense -- the interpreter is going to have to wrap a</span>
  <span class="co">-- function and get the argument from the environment.  In the HOAS</span>
  <span class="co">-- case, we simply make the function explicit in the type of the</span>
  <span class="co">-- method.</span>
<span class="ot">  dblam ::</span> repr (a, env) b <span class="ot">-&gt;</span> repr env (a <span class="ot">-&gt;</span> b)

  <span class="co">-- This method states that the environment contains a value of the</span>
  <span class="co">-- correct type to be applied: lambda 0</span>
<span class="ot">  zero ::</span> repr (a, env) a
  <span class="co">-- This method states that the environment is being extended with a</span>
  <span class="co">-- value of type 'b'.</span>
<span class="ot">  succ ::</span> repr env a <span class="ot">-&gt;</span> repr (b, env) a

<span class="kw">class</span> <span class="dt">FinalDBTermArith</span> repr <span class="kw">where</span>
<span class="ot">  dbadd ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbmul ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a
<span class="ot">  dbneg ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> repr env a <span class="ot">-&gt;</span> repr env a

<span class="kw">newtype</span> <span class="dt">EvalEnv</span> env a <span class="fu">=</span> <span class="dt">EvalEnv</span> {<span class="ot"> evalEnv ::</span> env <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">FinalDBTerm</span> <span class="dt">EvalEnv</span> <span class="kw">where</span>
  dbvar x <span class="fu">=</span> <span class="dt">EvalEnv</span> (const x)
  dbapp (<span class="dt">EvalEnv</span> f) (<span class="dt">EvalEnv</span> x) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> (f env) (x env)
  dblam (<span class="dt">EvalEnv</span> body) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env x <span class="ot">-&gt;</span> body (x, env)

  zero <span class="fu">=</span> <span class="dt">EvalEnv</span> fst
  succ (<span class="dt">EvalEnv</span> v) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> v <span class="fu">.</span> snd

<span class="kw">instance</span> <span class="dt">FinalDBTermArith</span> <span class="dt">EvalEnv</span> <span class="kw">where</span>
  dbadd (<span class="dt">EvalEnv</span> a) (<span class="dt">EvalEnv</span> b) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="fu">+</span> b env
  dbmul (<span class="dt">EvalEnv</span> a) (<span class="dt">EvalEnv</span> b) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="fu">*</span> b env
  dbneg (<span class="dt">EvalEnv</span> a) <span class="fu">=</span> <span class="dt">EvalEnv</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> negate <span class="fu">$</span> a env

dbeval expr <span class="fu">=</span> evalEnv expr ()

dbtest' <span class="fu">=</span> dblam (dbadd (succ zero) (succ (succ zero)))

dbtest'' <span class="fu">=</span> ((dblam (dblam dbtest') <span class="ot">`dbapp`</span> dbvar <span class="dv">22</span>) <span class="ot">`dbapp`</span> dbvar (<span class="dv">33</span><span class="ot"> ::</span> <span class="dt">Double</span>)) <span class="ot">`dbapp`</span> undefined

dbtest <span class="fu">=</span> dblam (dbadd zero zero) <span class="ot">`dbapp`</span> dbvar (<span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Double</span>)</code></pre></div>
</div>
<div id="de-bruijn-indices-initially-encoded" class="slide section level1">
<h1>De Bruijn Indices, Initially Encoded</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DBVar</span> env t <span class="kw">where</span>
  <span class="dt">DBZ</span><span class="ot"> ::</span> <span class="dt">DBVar</span> (t, env) t
  <span class="dt">DBS</span><span class="ot"> ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> <span class="dt">DBVar</span> (a, env) t

<span class="kw">data</span> <span class="dt">DBTerm</span> env t <span class="kw">where</span>
  <span class="dt">DBConst</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t
  <span class="dt">DBVar</span><span class="ot"> ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t
  <span class="dt">DBLam</span><span class="ot"> ::</span> <span class="dt">DBTerm</span> (a, env) b <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env (a <span class="ot">-&gt;</span> b)
  <span class="dt">DBApp</span><span class="ot"> ::</span> <span class="dt">DBTerm</span> env (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env a <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env b

<span class="ot">dbLookup ::</span> <span class="dt">DBVar</span> env t <span class="ot">-&gt;</span> env <span class="ot">-&gt;</span> t
dbLookup  <span class="dt">DBZ</span>    (x, _)   <span class="fu">=</span> x
dbLookup (<span class="dt">DBS</span> v) (_, env) <span class="fu">=</span> dbLookup v env

<span class="ot">dbEval ::</span> env <span class="ot">-&gt;</span> <span class="dt">DBTerm</span> env t <span class="ot">-&gt;</span> t
dbEval env (<span class="dt">DBVar</span> v) <span class="fu">=</span> dbLookup v env
dbEval env (<span class="dt">DBConst</span> t) <span class="fu">=</span> t
dbEval env (<span class="dt">DBLam</span> body) <span class="fu">=</span> \x <span class="ot">-&gt;</span> dbEval (x, env) body
dbEval env (<span class="dt">DBApp</span> f arg) <span class="fu">=</span> (dbEval env f) (dbEval env arg)

dbinitialtest <span class="fu">=</span> <span class="dt">DBApp</span> (<span class="dt">DBLam</span> (<span class="dt">DBVar</span> <span class="dt">DBZ</span>)) (<span class="dt">DBConst</span> <span class="dv">22</span>)</code></pre></div>
</div>
<div id="de-bruijn-index-to-hoas-conversion" class="slide section level1">
<h1>De Bruijn Index to HOAS Conversion</h1>
<p>For this final trick, I don't think there's a way to get away without either multi-parameter type classes with functional dependencies or type families. Our environment needs to have the same tuple structure, but all the types need to change from e.g. 'a' to 'repr a' (though the empty environment is still simply '()'). We don't have a general way to express this with Haskell 98. Type families (or MPTCs + fundeps) let us write type-level functions to explain to the type checker the appropriate relationships between the types in the environment.</p>
<p>Note that the conversion remains open! We could add new De Bruijn-based classes and new HOAS-based counterparts in a new module, along with the translation instances, and reuse this original 'toHOAS' function!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Env</span> repr a <span class="kw">where</span>
  <span class="dt">Env</span> repr () <span class="fu">=</span> ()
  <span class="dt">Env</span> repr (a, env) <span class="fu">=</span> (repr a, <span class="dt">Env</span> repr env)

<span class="kw">newtype</span> <span class="dt">WrapHOAS</span> repr env a <span class="fu">=</span> <span class="dt">WrapHOAS</span> {<span class="ot"> unwrapHOAS ::</span> <span class="dt">Env</span> repr env <span class="ot">-&gt;</span> repr a }

<span class="kw">instance</span> <span class="dt">FinalTerm</span> repr <span class="ot">=&gt;</span> <span class="dt">FinalDBTerm</span> (<span class="dt">WrapHOAS</span> repr) <span class="kw">where</span>
  dbvar x <span class="fu">=</span> <span class="dt">WrapHOAS</span> (const <span class="fu">$</span> var x)
  dbapp (<span class="dt">WrapHOAS</span> f) (<span class="dt">WrapHOAS</span> x) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> app (f env) (x env)
  dblam (<span class="dt">WrapHOAS</span> body) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> body (x, env)

  zero <span class="fu">=</span> <span class="dt">WrapHOAS</span> fst
  succ (<span class="dt">WrapHOAS</span> v) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> v <span class="fu">.</span> snd

<span class="kw">instance</span> <span class="dt">FinalTermArith</span> repr <span class="ot">=&gt;</span> <span class="dt">FinalDBTermArith</span> (<span class="dt">WrapHOAS</span> repr) <span class="kw">where</span>
  dbadd (<span class="dt">WrapHOAS</span> a) (<span class="dt">WrapHOAS</span> b) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="ot">`add`</span> b env
  dbmul (<span class="dt">WrapHOAS</span> a) (<span class="dt">WrapHOAS</span> b) <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> a env <span class="ot">`mul`</span> b env
  dbneg (<span class="dt">WrapHOAS</span> a)              <span class="fu">=</span> <span class="dt">WrapHOAS</span> <span class="fu">$</span> \env <span class="ot">-&gt;</span> neg <span class="fu">$</span> a env

<span class="ot">toHOAS ::</span> <span class="dt">WrapHOAS</span> repr () a <span class="ot">-&gt;</span> repr a
toHOAS expr <span class="fu">=</span> unwrapHOAS expr ()</code></pre></div>
</div>
<div id="church-encodings" class="slide section level1">
<h1>Church Encodings</h1>
</div>
<div id="scott-encodings" class="slide section level1">
<h1>Scott Encodings</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="kw">newtype</span> <span class="dt">SList</span> a <span class="fu">=</span> <span class="dt">SL</span> {<span class="ot"> elim ::</span> forall b<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b }

<span class="ot">snil ::</span> forall a<span class="fu">.</span> <span class="dt">SList</span> a
snil <span class="fu">=</span> <span class="dt">SL</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> n

<span class="ot">scons ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> a
scons x xs <span class="fu">=</span> <span class="dt">SL</span> <span class="fu">$</span> \c n <span class="ot">-&gt;</span> c x xs

<span class="ot">smap ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">SList</span> a <span class="ot">-&gt;</span> <span class="dt">SList</span> b
smap f lst <span class="fu">=</span> elim lst (\x xs <span class="ot">-&gt;</span> f x <span class="ot">`scons`</span> smap f xs) snil</code></pre></div>
</div>
<div id="codensity-transformation" class="slide section level1">
<h1>Codensity Transformation</h1>
</div>
<div id="optimization-example" class="slide section level1">
<h1>Optimization example?</h1>
</div>
<div id="tdpe" class="slide section level1">
<h1>TDPE?</h1>
</div>
</body>
</html>
